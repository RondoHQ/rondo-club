# PWA Enhancement Research Summary

**Project:** Stadion v8.0 PWA Enhancement
**Domain:** Progressive Web App for Personal CRM (React SPA + WordPress Backend)
**Researched:** 2026-01-28
**Confidence:** HIGH

## Executive Summary

Adding PWA capabilities to Stadion's existing React SPA + WordPress architecture is straightforward using vite-plugin-pwa with minimal additional dependencies. The recommended approach uses Workbox's generateSW strategy for automatic service worker generation, NetworkFirst caching for WordPress REST API endpoints, and careful coordination with TanStack Query's existing cache layer. This enables home screen installation on iOS and Android, basic offline support showing cached data, and smart update notifications.

The critical architectural insight is that iOS Safari imposes severe limitations compared to Android Chrome: no programmatic install prompts, 7-day storage eviction for inactive users, and 50MB cache limits. Therefore, the PWA strategy must be designed for graceful degradation, treating all offline data as transient cache rather than persistent storage. TanStack Query already handles this pattern well, making integration cleaner than typical PWA implementations.

Key risks center on double-caching conflicts between service worker and TanStack Query, iOS-specific UI issues (safe area insets, pull-to-refresh gestures), and service worker update management. These are all preventable with proper configuration in Phase 1 and careful testing in standalone mode on real devices. The most critical decision is choosing NetworkFirst (or no caching) for API routes to avoid serving stale data when TanStack Query expects fresh responses.

## Key Findings

### Recommended Stack

**vite-plugin-pwa (v0.20+)** is the de facto standard for Vite-based PWAs, providing zero-config integration with Vite's build pipeline. It wraps Workbox's generateSW and injectManifest methods, handling manifest generation and service worker creation automatically. For Stadion's needs (install to home screen, basic offline, pull-to-refresh, update notifications), generateSW provides sufficient functionality without the maintenance burden of custom service worker code.

**Core technologies:**
- **vite-plugin-pwa (v0.20+)**: PWA generation and service worker creation — Zero-config, integrates with Vite 5+, actively maintained
- **workbox-window (v7.3+)**: Service worker lifecycle management — Auto-installed peer dependency, handles registration and updates
- **react-simple-pull-to-refresh (v1.3.3)**: Mobile pull-to-refresh gesture — Zero dependencies, 40K weekly downloads, works on iOS/Android
- **Native beforeinstallprompt API**: Install prompt on Android — No library needed, ~20 lines custom hook, iOS requires manual add to home screen

**Platform support matrix:** Chrome/Edge desktop and Android have full PWA features. iOS Safari supports service workers (with 50MB cache limit) and standalone mode, but lacks programmatic install prompts and has 7-day storage eviction policy. Firefox and Safari desktop support service workers but not install prompts.

### Expected Features

**Must have (table stakes):**
- Web App Manifest with icons (192x192, 512x512) and Apple Touch icons (180x180)
- HTTPS serving (required for service workers)
- Service worker registration for offline capability
- Standalone display mode (app runs without browser chrome)
- Basic offline fallback showing cached data
- Theme color and splash screen

**Should have (competitive):**
- Smart install prompt on Android (prompts after 2-3 valuable actions)
- Update notification UI letting users control when to refresh
- Offline data access via TanStack Query + service worker cache coordination
- Pull-to-refresh gesture on mobile (medium complexity, defer to post-MVP)
- App shortcuts for quick actions (Android only, nice-to-have)

**Defer (v2+):**
- Push notifications (requires backend FCM infrastructure, iOS 16.4+ only)
- Full offline editing with conflict resolution (complex queueing, IndexedDB transactions)
- Background sync for mutations (Android-only API, high complexity)
- Native app features like contacts API (poor browser support)
- Precaching all contacts (storage limits, bandwidth waste)

### Architecture Approach

PWA features integrate through vite-plugin-pwa extending the Vite build pipeline to generate manifest.webmanifest and sw.js at build time. WordPress serves these assets alongside the existing React SPA via wp_head hook for manifest link and service worker registration in main.jsx. The service worker must be served from theme root (not /dist/) to control the entire frontend scope while excluding /wp-admin/ paths.

**Major components:**
1. **Manifest + Icons** — Generated by vite-plugin-pwa, served via WordPress wp_head, includes both web manifest icons and Apple Touch icons for iOS
2. **Service Worker** — Generated in dist/, copied to theme root post-build, registers in main.jsx with update callbacks, uses NetworkFirst for API routes
3. **Cache Coordination** — Service worker handles NetworkFirst for /wp-json/* endpoints (timeout 10s, fallback to cache), TanStack Query uses networkMode: 'offlineFirst' to work with service worker
4. **Update Management** — registerType: 'prompt' strategy shows user notification when update available, user controls when to reload, prevents mid-session disruption

**Critical integration points:** Service worker scope configuration to exclude /wp-admin/, post-build copy script to move sw.js to theme root, TanStack Query networkMode coordination, and server Cache-Control headers to prevent sw.js caching.

### Critical Pitfalls

1. **iOS 7-Day Storage Eviction** — Accept this limitation, design for graceful degradation. iOS wipes all PWA storage (cache, IndexedDB, localStorage) after 7 days of non-use. Solution: Treat offline data as transient cache, optimize initial data fetch on cold start, document limitation for users.

2. **Service Worker + TanStack Query Double-Caching Conflict** — Service worker serves cached API responses, making TanStack Query refetch pointless. Solution: Use NetworkFirst strategy for /wp-json/ endpoints (fresh data first, cache only for offline fallback), or don't cache API responses in service worker at all. TanStack Query already provides optimal caching.

3. **skipWaiting() Causes Version Mismatch** — New service worker activates mid-session, page has old JS bundle but service worker serves new assets. Result: broken functionality, React errors, missing chunks. Solution: Use registerType: 'prompt', show non-intrusive update notification, let user control when to refresh. Never auto-update without consent.

4. **iOS Pull-to-Refresh Conflicts with Scrolling** — iOS standalone mode enables pull-to-refresh gesture by default, accidental page reloads lose app state. Solution: Add CSS overscroll-behavior-y: none to body, provide alternative refresh mechanism in UI.

5. **iOS Safe Area Insets Not Handled** — Content gets hidden behind notch/home indicator on iPhone. Solution: Add viewport-fit=cover to viewport meta tag, use CSS env(safe-area-inset-*) for padding, add apple-mobile-web-app-status-bar-style meta tag.

## Implications for Roadmap

Based on research, suggested phase structure prioritizes foundational setup, then cache strategy coordination, then polish and testing. Total implementation: 4-6 days.

### Phase 1: PWA Foundation (1-2 days)
**Rationale:** Establish manifest, service worker, and iOS compatibility basics before any caching logic. This phase makes the app installable and handles platform-specific quirks.

**Delivers:**
- Installable PWA on iOS and Android (manual on iOS, auto-prompt on Android)
- Service worker registered and active
- iOS-specific fixes (safe area insets, pull-to-refresh prevention, Apple Touch icons)
- Server configuration preventing sw.js caching

**Addresses features:**
- Web app manifest with icons (table stakes)
- HTTPS serving (already in place)
- Service worker registration (table stakes)
- Standalone display mode (table stakes)
- Theme color and splash screen (table stakes)

**Avoids pitfalls:**
- Pitfall 4: iOS pull-to-refresh (add overscroll-behavior-y: none)
- Pitfall 6: iOS safe area insets (viewport-fit=cover + CSS)
- Pitfall 7: iOS manifest icons (apple-touch-icon meta tags)
- Pitfall 10: Stale service worker (Cache-Control headers)
- Pitfall 13: Missing manifest fields (comprehensive manifest config)

**Critical decisions:**
- Choose service worker strategy (recommend generateSW for MVP simplicity)
- Configure vite-plugin-pwa in vite.config.js
- Add post-build script to copy sw.js to theme root

### Phase 2: Cache Strategy & Update Management (1-2 days)
**Rationale:** With PWA installable, configure caching to work with TanStack Query without conflicts. This is the most critical phase for avoiding double-caching pitfalls.

**Delivers:**
- NetworkFirst caching for WordPress REST API (or no API caching)
- Precaching for static assets (JS, CSS, fonts)
- Update notification UI with user-controlled refresh
- Cache cleanup strategy for old versions

**Addresses features:**
- Basic offline fallback (table stakes)
- Update notification (should have)
- Offline data access coordination (should have)

**Avoids pitfalls:**
- Pitfall 2: Service worker + TanStack Query conflict (NetworkFirst or no API caching)
- Pitfall 3: skipWaiting version mismatch (registerType: 'prompt' with custom UI)
- Pitfall 11: precacheAndRoute caches wrong files (explicit globPatterns)
- Pitfall 15: No update notification (implement prompt UI)
- Pitfall 16: Orphaned cache entries (cleanupOutdatedCaches: true)

**Uses stack elements:**
- workbox-window for lifecycle management
- TanStack Query networkMode: 'offlineFirst'
- vite-plugin-pwa registerType: 'prompt'

**Implements architecture components:**
- Cache coordination layer between service worker and TanStack Query
- Update notification component with useRegisterSW hook

### Phase 3: Smart Install Prompt (1 day)
**Rationale:** With core PWA functional, add user engagement features. Install prompt increases install rate on Android.

**Delivers:**
- Custom install button shown after user engagement
- beforeinstallprompt event handling
- iOS manual install instructions (modal with screenshots)
- Install analytics tracking

**Addresses features:**
- Smart install prompt (should have, Android only)

**Avoids pitfalls:**
- Pitfall 5: iOS no back button (ensure navigation patterns tested)
- Pitfall 8: EU users can't install (detection and messaging)

**Implementation:**
- Custom React hook for beforeinstallprompt (no library needed)
- Show install button after viewing 2 people OR adding 1 note
- iOS-specific UI guidance for manual "Add to Home Screen"

### Phase 4: Testing & Polish (1-2 days)
**Rationale:** Test in standalone mode on real devices to catch iOS-specific issues before launch.

**Delivers:**
- Full testing on iOS and Android devices in standalone mode
- Offline mode verification
- Update flow end-to-end testing
- Lighthouse PWA audit (target score > 90)
- Documentation of iOS 7-day limitation

**Avoids pitfalls:**
- Pitfall 17: Testing in browser instead of standalone mode
- Pitfall 18: Service worker cache hides bugs in dev
- Pitfall 19: WordPress nonce expiration (detection and clear error)
- Pitfall 20: WordPress cache plugins conflict (SiteGround exclusions)

**Testing checklist:**
- Install on iPhone (iOS 16+) and Android device
- Test navigation in standalone mode (no dead ends)
- Test offline mode (airplane mode)
- Deploy update and verify notification appears
- Confirm no content behind notch/home indicator
- Verify pull-to-refresh disabled

### Phase Ordering Rationale

- **Phase 1 before Phase 2:** Must have working service worker and iOS compatibility before configuring caching logic. Trying to debug cache issues while also fighting iOS quirks is too complex.
- **Phase 2 before Phase 3:** Cache strategy must work correctly before adding install prompt. Users who install a broken PWA will uninstall immediately.
- **Phase 3 standalone:** Install prompt is pure enhancement, doesn't affect core functionality, can be done in parallel with other polish work.
- **Phase 4 at end:** Real device testing requires working PWA, catches issues early enough to fix before launch.

**Dependencies discovered:**
- Service worker scope depends on file location (theme root vs /dist/)
- iOS features require specific HTML meta tags (can't be added via manifest)
- TanStack Query configuration must align with service worker caching strategy
- WordPress nonce expiration affects offline action replay

### Research Flags

**Phases with standard patterns (skip research-phase):**
- **Phase 1:** PWA foundation is well-documented, official Vite PWA plugin guide covers all setup
- **Phase 2:** Cache strategies are standard Workbox patterns, TanStack Query offline docs are clear
- **Phase 3:** Install prompt is native browser API, implementation patterns are established
- **Phase 4:** Testing requires real devices, not research

**No phases need deeper research.** All research dimensions (stack, features, architecture, pitfalls) are HIGH confidence with verified official sources.

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | Official Vite PWA plugin documentation, verified npm package stats, clear version compatibility |
| Features | MEDIUM | iOS limitations documented in multiple sources but specific behaviors (7-day eviction) may vary by version |
| Architecture | HIGH | Official documentation for Vite, Workbox, TanStack Query integration patterns |
| Pitfalls | HIGH | Based on official Google documentation, verified community reports, Vite PWA issues |

**Overall confidence:** HIGH

Research covers all critical aspects with official documentation. iOS-specific behaviors have medium confidence because Apple's PWA support evolves with each iOS version, but limitations are consistent across recent versions (iOS 13.4+).

### Gaps to Address

**iOS 7-day eviction edge cases:** Research confirms this limitation exists, but exact trigger conditions (app not opened vs app not used actively) unclear. Handle during Phase 4 testing: document user experience, optimize cold start performance, add clear messaging.

**TanStack Query networkMode interaction:** Documentation covers networkMode: 'offlineFirst' but interaction with service worker NetworkFirst strategy needs verification. Handle during Phase 2: test both approaches (no API caching vs NetworkFirst), choose based on actual behavior.

**WordPress nonce expiration in offline mode:** Research identifies the issue but mitigation strategy needs testing. Handle during Phase 4: implement nonce validation before mutation execution, test offline period > 12 hours, ensure clear error messaging.

**SiteGround cache configuration:** Research identifies potential conflict but specific SiteGround dashboard settings need verification. Handle during Phase 1 deployment: check production cache headers, configure exclusions if needed, test sw.js Cache-Control.

**Pull-to-refresh on iOS:** Research shows it's "buggy" but didn't specify exact issues. Handle during Phase 4: test on real iOS device, decide whether to implement custom pull-to-refresh or rely on explicit refresh button in UI.

## Sources

### Primary (HIGH confidence)

**Official Documentation:**
- [Vite Plugin PWA Guide](https://vite-pwa-org.netlify.app/guide/) — Complete PWA setup, service worker strategies, React integration
- [Workbox Strategies - Chrome for Developers](https://developer.chrome.com/docs/workbox/modules/workbox-strategies) — NetworkFirst, CacheFirst patterns
- [MDN: Progressive Web Apps](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps) — Web standards reference
- [MDN: Web App Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest) — Manifest specification
- [TanStack Query Network Mode](https://tanstack.com/query/v4/docs/framework/react/guides/network-mode) — offlineFirst behavior

**Library Documentation:**
- [vite-plugin-pwa GitHub](https://github.com/vite-pwa/vite-plugin-pwa) — Plugin API, examples
- [react-simple-pull-to-refresh npm](https://www.npmjs.com/package/react-simple-pull-to-refresh) — Usage, API reference

### Secondary (MEDIUM confidence)

**Implementation Patterns:**
- [Making totally offline-available PWAs with Vite and React](https://adueck.github.io/blog/caching-everything-for-totally-offline-pwa-vite-react/) — Real-world implementation
- [Offline React Query - TkDodo](https://tkdodo.eu/blog/offline-react-query) — TanStack Query offline strategies by maintainer
- [Advanced Caching Strategies with Workbox](https://medium.com/animall-engineering/advanced-caching-strategies-with-workbox-beyond-stalewhilerevalidate-d000f1d27d0a) — NetworkFirst patterns

**iOS Limitations:**
- [PWA iOS Limitations and Safari Support - MagicBell](https://www.magicbell.com/blog/pwa-ios-limitations-safari-support-complete-guide) — Comprehensive iOS limitation guide
- [PWA on iOS - Current Status & Limitations - Brainhub](https://brainhub.eu/library/pwa-on-ios) — 2025 iOS PWA status
- [Navigating Safari/iOS PWA Limitations - Vinova](https://vinova.sg/navigating-safari-ios-pwa-limitations/) — Storage persistence, 7-day eviction

**Service Worker Patterns:**
- [Handling Service Worker Updates - WhatWebCanDo](https://whatwebcando.today/articles/handling-service-worker-updates/) — Update strategies
- [Rich Harris - Stuff I wish I'd known about service workers](https://gist.github.com/Rich-Harris/fd6c3c73e6e707e312d7c5d7d0f3b2f9) — Common pitfalls
- [Workbox - Handling Service Worker Updates](https://developer.chrome.com/docs/workbox/handling-service-worker-updates) — Official update patterns

### Tertiary (LOW confidence)

**WordPress Integration:**
- [WordPress PWA Service Worker Integration](https://github.com/GoogleChromeLabs/pwa-wp/wiki/Service-Worker) — Archived project, patterns still relevant
- [Implementing A Service Worker For Single-Page App WordPress Sites](https://www.smashingmagazine.com/2017/10/service-worker-single-page-application-wordpress-sites/) — 2017 article, architectural concepts valid

---
*Research completed: 2026-01-28*
*Ready for roadmap: yes*
