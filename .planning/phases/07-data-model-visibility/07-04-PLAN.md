---
phase: 07-data-model-visibility
plan: 04
type: execute
depends_on: ["07-02", "07-03"]
files_modified: [includes/class-access-control.php]
---

<objective>
Extend PRM_Access_Control to check visibility, workspace membership, and direct shares.

Purpose: Enable contacts to be accessed by workspace members and shared users, not just the author.
Output: Updated access control that respects visibility, workspace membership, and shares.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@Caelis-Multi-User-Project-Plan.md (section 1.6)
@includes/class-access-control.php
@.planning/phases/07-data-model-visibility/07-02-SUMMARY.md
@.planning/phases/07-data-model-visibility/07-03-SUMMARY.md

**Permission resolution order:**
1. Is user the author? → Full access
2. Is _visibility = 'private'? → Deny (unless #1)
3. Is _visibility = 'workspace'? → Check workspace membership → Allow with role-based permission
4. Check _shared_with for user → Allow with specified permission
5. Deny

**Key insight:**
- get_accessible_post_ids() must be extended to include workspace-visible and shared posts
- user_can_access_post() must check the full permission chain
- REST filters use the same logic
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend get_accessible_post_ids for visibility/workspaces/shares</name>
  <files>includes/class-access-control.php</files>
  <action>
Rewrite get_accessible_post_ids() to include posts where:
1. User is author (existing)
2. _visibility = 'workspace' AND user is member of any assigned workspace
3. User appears in _shared_with meta

New implementation:

```php
public function get_accessible_post_ids($post_type, $user_id) {
    global $wpdb;

    // 1. Posts authored by user (existing)
    $authored = $wpdb->get_col($wpdb->prepare(
        "SELECT ID FROM {$wpdb->posts}
         WHERE post_type = %s
         AND post_status = 'publish'
         AND post_author = %d",
        $post_type,
        $user_id
    ));

    // 2. Workspace-visible posts where user is member
    $workspace_ids = PRM_Workspace_Members::get_user_workspace_ids($user_id);
    $workspace_posts = [];

    if (!empty($workspace_ids)) {
        // Get posts with _visibility = 'workspace' that have matching workspace_access terms
        // Build term slugs from workspace IDs
        $term_slugs = array_map(function($id) {
            return 'workspace-' . $id;
        }, $workspace_ids);

        $placeholders = implode(',', array_fill(0, count($term_slugs), '%s'));

        $workspace_posts = $wpdb->get_col($wpdb->prepare(
            "SELECT DISTINCT p.ID
             FROM {$wpdb->posts} p
             INNER JOIN {$wpdb->postmeta} pm ON p.ID = pm.post_id
             INNER JOIN {$wpdb->term_relationships} tr ON p.ID = tr.object_id
             INNER JOIN {$wpdb->term_taxonomy} tt ON tr.term_taxonomy_id = tt.term_taxonomy_id
             INNER JOIN {$wpdb->terms} t ON tt.term_id = t.term_id
             WHERE p.post_type = %s
             AND p.post_status = 'publish'
             AND pm.meta_key = '_visibility'
             AND pm.meta_value = 'workspace'
             AND tt.taxonomy = 'workspace_access'
             AND t.slug IN ($placeholders)",
            array_merge([$post_type], $term_slugs)
        ));
    }

    // 3. Posts shared directly with user
    // _shared_with is serialized array, so we use LIKE for the user_id
    $shared_posts = $wpdb->get_col($wpdb->prepare(
        "SELECT DISTINCT p.ID
         FROM {$wpdb->posts} p
         INNER JOIN {$wpdb->postmeta} pm ON p.ID = pm.post_id
         WHERE p.post_type = %s
         AND p.post_status = 'publish'
         AND pm.meta_key = '_shared_with'
         AND pm.meta_value LIKE %s",
        $post_type,
        '%"user_id":' . $user_id . '%'
    ));

    // Merge and dedupe
    $all_ids = array_unique(array_merge($authored, $workspace_posts, $shared_posts));

    return $all_ids;
}
```

Note: The LIKE query for _shared_with is simple but may need optimization for large datasets (Phase 8/later).
  </action>
  <verify>Create test person with _visibility='workspace', assign to workspace, verify non-owner member can access via REST API</verify>
  <done>get_accessible_post_ids returns correct posts for all three access types</done>
</task>

<task type="auto">
  <name>Task 2: Update user_can_access_post for full permission chain</name>
  <files>includes/class-access-control.php</files>
  <action>
Rewrite user_can_access_post() to check the full chain:

```php
public function user_can_access_post($post_id, $user_id = null) {
    if ($user_id === null) {
        $user_id = get_current_user_id();
    }

    // Check if user is approved (admins are always approved)
    if (!user_can($user_id, 'manage_options')) {
        if (!PRM_User_Roles::is_user_approved($user_id)) {
            return false;
        }
    }

    $post = get_post($post_id);

    if (!$post || !in_array($post->post_type, $this->controlled_post_types)) {
        return true; // Not a controlled post type
    }

    // Don't allow access to trashed posts
    if ($post->post_status === 'trash') {
        return false;
    }

    // 1. Check if user is the author → Full access
    if ((int) $post->post_author === (int) $user_id) {
        return true;
    }

    // Admins in admin area have full access (unchanged)
    if (user_can($user_id, 'manage_options') && !$this->is_frontend()) {
        return true;
    }

    // 2. Check visibility
    $visibility = PRM_Visibility::get_visibility($post_id);

    // Private = only author (already checked above)
    if ($visibility === PRM_Visibility::PRIVATE) {
        return false;
    }

    // 3. Workspace visibility check
    if ($visibility === PRM_Visibility::WORKSPACE) {
        // Get user's workspace IDs
        $user_workspace_ids = PRM_Workspace_Members::get_user_workspace_ids($user_id);

        if (!empty($user_workspace_ids)) {
            // Check if post has any matching workspace_access terms
            $post_terms = wp_get_post_terms($post_id, 'workspace_access', ['fields' => 'slugs']);

            if (!is_wp_error($post_terms)) {
                foreach ($post_terms as $slug) {
                    // Term slug format: 'workspace-{ID}'
                    $workspace_id = (int) str_replace('workspace-', '', $slug);
                    if (in_array($workspace_id, $user_workspace_ids)) {
                        return true;
                    }
                }
            }
        }
    }

    // 4. Check direct shares
    if (PRM_Visibility::user_has_share($post_id, $user_id)) {
        return true;
    }

    // 5. Deny
    return false;
}
```

Also add a method to get permission level (for edit vs view-only):

```php
/**
 * Get user's permission level for a post
 * @return string|false 'owner', 'admin', 'member', 'viewer', 'edit', 'view', or false
 */
public function get_user_permission($post_id, $user_id = null) {
    if ($user_id === null) {
        $user_id = get_current_user_id();
    }

    if (!$this->user_can_access_post($post_id, $user_id)) {
        return false;
    }

    $post = get_post($post_id);

    // Owner
    if ((int) $post->post_author === (int) $user_id) {
        return 'owner';
    }

    // Workspace role
    $visibility = PRM_Visibility::get_visibility($post_id);
    if ($visibility === PRM_Visibility::WORKSPACE) {
        $user_workspace_ids = PRM_Workspace_Members::get_user_workspace_ids($user_id);
        $post_terms = wp_get_post_terms($post_id, 'workspace_access', ['fields' => 'slugs']);

        if (!is_wp_error($post_terms)) {
            foreach ($post_terms as $slug) {
                $workspace_id = (int) str_replace('workspace-', '', $slug);
                if (in_array($workspace_id, $user_workspace_ids)) {
                    $role = PRM_Workspace_Members::get_user_role($workspace_id, $user_id);
                    if ($role) {
                        return $role; // 'admin', 'member', or 'viewer'
                    }
                }
            }
        }
    }

    // Direct share permission
    $share_permission = PRM_Visibility::get_share_permission($post_id, $user_id);
    if ($share_permission) {
        return $share_permission; // 'edit' or 'view'
    }

    return false;
}
```
  </action>
  <verify>Test with different visibility/workspace/share combinations to verify correct access</verify>
  <done>user_can_access_post and get_user_permission work correctly for all access scenarios</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Extended access control with visibility, workspace membership, and share checks</what-built>
  <how-to-verify>
    1. Create a workspace via WordPress admin
    2. Note the workspace ID
    3. Create two test users (User A and User B) via WordPress admin
    4. As User A: Create a person, set visibility to "Workspace", assign workspace_access term manually
    5. Add User B to the workspace via database: update user meta _workspace_memberships
    6. As User B: Call REST API GET /wp/v2/people - should see User A's person
    7. As a third user not in workspace: Should NOT see the person

    Alternative quick test:
    1. SSH to server or use wp-cli
    2. wp eval "var_dump(PRM_Visibility::set_visibility(123, 'workspace'));" (use real post ID)
    3. wp eval "var_dump(PRM_Workspace_Members::add(WORKSPACE_ID, USER_ID, 'member'));"
    4. wp eval "var_dump((new PRM_Access_Control())->user_can_access_post(123, USER_ID));"
  </how-to-verify>
  <resume-signal>Type "approved" if access control works correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Author still has full access to their own posts
- [ ] Private posts are only visible to author
- [ ] Workspace-visible posts are accessible to workspace members
- [ ] Shared posts are accessible to users in _shared_with
- [ ] Non-authorized users cannot access any restricted posts
- [ ] REST API respects all access rules
- [ ] `npm run build` succeeds
- [ ] No PHP errors in debug log
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Existing functionality preserved (private contacts still work)
- New visibility/workspace/share access working
- Phase 7 complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-model-visibility/07-04-SUMMARY.md`
</output>
