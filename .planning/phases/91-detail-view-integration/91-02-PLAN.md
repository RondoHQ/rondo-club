---
phase: 91-detail-view-integration
plan: 02
type: execute
wave: 2
depends_on: ["91-01"]
files_modified:
  - src/components/CustomFieldsSection.jsx
  - src/components/CustomFieldsEditModal.jsx
  - src/pages/People/PersonDetail.jsx
  - src/pages/Companies/CompanyDetail.jsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Person detail view shows Custom Fields section when custom fields are defined"
    - "Organization detail view shows Custom Fields section when custom fields are defined"
    - "Each field type renders appropriately for its data type"
    - "Users can edit custom field values via modal"
    - "Section hides when no custom fields are defined for that post type"
  artifacts:
    - path: "src/components/CustomFieldsSection.jsx"
      provides: "Reusable section component for displaying custom fields"
      exports: ["default"]
      min_lines: 150
    - path: "src/components/CustomFieldsEditModal.jsx"
      provides: "Modal for editing all custom field values"
      exports: ["default"]
      min_lines: 200
  key_links:
    - from: "src/components/CustomFieldsSection.jsx"
      to: "/stadion/v1/custom-fields/{post_type}/metadata"
      via: "useQuery with prmApi.getCustomFieldsMetadata"
      pattern: "prmApi\\.getCustomFieldsMetadata"
    - from: "src/pages/People/PersonDetail.jsx"
      to: "src/components/CustomFieldsSection.jsx"
      via: "import and render"
      pattern: "CustomFieldsSection"
    - from: "src/pages/Companies/CompanyDetail.jsx"
      to: "src/components/CustomFieldsSection.jsx"
      via: "import and render"
      pattern: "CustomFieldsSection"
---

<objective>
Create Custom Fields section component and integrate into detail pages

Purpose: Users need to view and edit custom field values on Person and Organization detail pages. This completes the DISP-01, DISP-02, DISP-03, DISP-04 requirements.

Output: Custom Fields section appears on detail pages with type-appropriate rendering and modal-based editing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/91-detail-view-integration/91-RESEARCH.md
@.planning/phases/91-detail-view-integration/91-01-SUMMARY.md

@src/pages/People/PersonDetail.jsx
@src/pages/Companies/CompanyDetail.jsx
@src/components/ContactEditModal.jsx
@src/components/FieldFormPanel.jsx
@src/api/client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomFieldsSection component</name>
  <files>src/components/CustomFieldsSection.jsx</files>
  <action>
Create a reusable component for displaying custom fields on detail pages.

**Props:**
- `postType`: 'person' | 'company'
- `postId`: number - the post ID
- `acfData`: object - the `person.acf` or `company.acf` object
- `onUpdate`: function - callback after successful save, receives updated acf data
- `isUpdating`: boolean - whether parent is currently saving

**Structure:**
```jsx
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Pencil, ExternalLink, File, Link as LinkIcon } from 'lucide-react';
import { format } from 'date-fns';
import { Link } from 'react-router-dom';
import { prmApi } from '@/api/client';
import CustomFieldsEditModal from './CustomFieldsEditModal';
```

**Implementation:**

1. **Fetch field definitions** using `useQuery`:
   ```jsx
   const { data: fieldDefs = [], isLoading } = useQuery({
     queryKey: ['custom-fields-metadata', postType],
     queryFn: async () => {
       const response = await prmApi.getCustomFieldsMetadata(postType);
       return response.data;
     },
   });
   ```

2. **Early return if no fields**: If `fieldDefs.length === 0` and not loading, return `null` (don't show section)

3. **Section layout** following Stadion pattern:
   ```jsx
   <div className="card p-6 break-inside-avoid mb-6">
     <div className="flex items-center justify-between mb-4">
       <h2 className="font-semibold">Custom fields</h2>
       <button onClick={() => setShowModal(true)} className="btn-secondary text-sm">
         <Pencil className="w-4 h-4 md:mr-1" />
         <span className="hidden md:inline">Edit</span>
       </button>
     </div>
     {/* Field list */}
   </div>
   ```

4. **Field display rendering** - create a `renderFieldValue` function that handles all 14 types:

   - **text, textarea, number**: Plain text display
   - **email**: `mailto:` link with accent color
   - **url**: External link with icon
   - **date**: Formatted using `date-fns format()` - use field's `display_format` if available, else 'PP'
   - **select**: Show value (it's already the display value from ACF)
   - **checkbox**: Join array values with comma
   - **true_false**: Show `ui_on_text`/`ui_off_text` or "Yes"/"No"
   - **image**: Thumbnail preview (handle both URL string and object with `url` property)
   - **file**: Download link with file icon
   - **link**: Clickable link using `title` and `url` properties
   - **color_picker**: Color swatch + hex value
   - **relationship**: Links to related person(s)/company(s)

   For empty/null values: show "Not set" in italic gray text

5. **Field list layout**:
   ```jsx
   <div className="space-y-3">
     {fieldDefs.map((field) => (
       <div key={field.key} className="flex items-start">
         <div className="w-1/3 text-sm text-gray-500 dark:text-gray-400 pt-0.5">
           {field.label}
         </div>
         <div className="w-2/3 text-sm">
           {renderFieldValue(field, acfData?.[field.name])}
         </div>
       </div>
     ))}
   </div>
   ```

6. **Modal integration**:
   ```jsx
   {showModal && (
     <CustomFieldsEditModal
       isOpen={showModal}
       onClose={() => setShowModal(false)}
       postType={postType}
       postId={postId}
       fieldDefs={fieldDefs}
       currentValues={acfData}
       onSubmit={handleSubmit}
       isLoading={isUpdating}
     />
   )}
   ```

**Relationship field handling:**
- Relationship values can be IDs or objects depending on return_format
- If array of IDs: fetch post titles or show IDs with links
- If array of objects: use post_title directly
- Link to `/people/{id}` or `/companies/{id}` based on the related post's type

**Image/File handling:**
- Check `typeof value` - can be number (ID), string (URL), or object ({url, filename, etc.})
- For objects, use `value.url` or `value.sizes?.thumbnail`
- For image: show 64x64 preview
- For file: show filename with download link
  </action>
  <verify>
- Component renders without errors when imported
- Handles all 14 field types appropriately
- Shows "Not set" for empty values
- Returns null when no fields defined
  </verify>
  <done>
- CustomFieldsSection component created at src/components/CustomFieldsSection.jsx
- Displays all custom field types appropriately
- Integrates with edit modal
- Handles empty states (no fields, no values)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CustomFieldsEditModal component</name>
  <files>src/components/CustomFieldsEditModal.jsx</files>
  <action>
Create a modal for editing custom field values, following the ContactEditModal pattern.

**Props:**
- `isOpen`: boolean
- `onClose`: function
- `postType`: 'person' | 'company'
- `postId`: number
- `fieldDefs`: array of field definitions
- `currentValues`: object - current ACF values
- `onSubmit`: function - receives updated values object
- `isLoading`: boolean

**Structure:**
```jsx
import { useEffect, useRef, useState } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { X, Upload, Trash2 } from 'lucide-react';
import { format, parse } from 'date-fns';
import Sketch from '@uiw/react-color-sketch';
import { wpApi, prmApi } from '@/api/client';
import { useQuery } from '@tanstack/react-query';
```

**Implementation:**

1. **Form setup with react-hook-form**:
   ```jsx
   const { register, handleSubmit, control, reset, setValue, watch } = useForm({
     defaultValues: buildDefaultValues(fieldDefs, currentValues),
   });
   ```

2. **Modal layout** following ContactEditModal pattern:
   - Fixed overlay with centered modal
   - Header with title and close button
   - Scrollable content area
   - Footer with Cancel/Save buttons

3. **Field input rendering** - create `renderFieldInput` for all 14 types:

   **text, email, url:**
   ```jsx
   <input type={field.type} {...register(field.name)} className="input" />
   ```

   **textarea:**
   ```jsx
   <textarea {...register(field.name)} rows={4} className="input" />
   ```

   **number:**
   ```jsx
   <div className="flex items-center gap-2">
     {field.prepend && <span className="text-gray-500">{field.prepend}</span>}
     <input type="number" {...register(field.name)}
       min={field.min} max={field.max} step={field.step}
       className="input flex-1" />
     {field.append && <span className="text-gray-500">{field.append}</span>}
   </div>
   ```

   **date:**
   ```jsx
   <input type="date" {...register(field.name)} className="input" />
   ```
   Note: Store as YYYY-MM-DD format, ACF handles display formatting

   **select:**
   ```jsx
   <select {...register(field.name)} className="input">
     <option value="">Select...</option>
     {Object.entries(field.choices || {}).map(([value, label]) => (
       <option key={value} value={value}>{label}</option>
     ))}
   </select>
   ```

   **checkbox:**
   Use Controller for array values:
   ```jsx
   <Controller
     name={field.name}
     control={control}
     render={({ field: { value = [], onChange } }) => (
       <div className="space-y-2">
         {Object.entries(fieldDef.choices || {}).map(([key, label]) => (
           <label key={key} className="flex items-center gap-2">
             <input
               type="checkbox"
               checked={value.includes(key)}
               onChange={(e) => {
                 if (e.target.checked) {
                   onChange([...value, key]);
                 } else {
                   onChange(value.filter(v => v !== key));
                 }
               }}
             />
             {label}
           </label>
         ))}
       </div>
     )}
   />
   ```

   **true_false:**
   ```jsx
   <Controller
     name={field.name}
     control={control}
     render={({ field: { value, onChange } }) => (
       <label className="flex items-center gap-2">
         <input type="checkbox" checked={!!value} onChange={(e) => onChange(e.target.checked ? 1 : 0)} />
         <span>{value ? (fieldDef.ui_on_text || 'Yes') : (fieldDef.ui_off_text || 'No')}</span>
       </label>
     )}
   />
   ```

   **image:**
   Use file input with preview:
   ```jsx
   <Controller
     name={field.name}
     control={control}
     render={({ field: { value, onChange } }) => (
       <ImageInput value={value} onChange={onChange} />
     )}
   />
   ```
   - Show current image preview if exists
   - File input for new upload
   - Upload via `wpApi.uploadMedia`, store resulting ID or object based on return_format

   **file:**
   Similar to image but show filename instead of preview

   **link:**
   Two inputs for URL and title:
   ```jsx
   <div className="space-y-2">
     <input type="url" {...register(`${field.name}.url`)} placeholder="URL" className="input" />
     <input type="text" {...register(`${field.name}.title`)} placeholder="Link text" className="input" />
   </div>
   ```

   **color_picker:**
   Use @uiw/react-color-sketch (already in project):
   ```jsx
   <Controller
     name={field.name}
     control={control}
     render={({ field: { value, onChange } }) => (
       <ColorPickerInput value={value} onChange={onChange} />
     )}
   />
   ```
   - Show color swatch preview
   - Click to open picker
   - Close picker on outside click

   **relationship:**
   Use autocomplete search for people/companies:
   ```jsx
   <Controller
     name={field.name}
     control={control}
     render={({ field: { value, onChange } }) => (
       <RelationshipInput
         value={value}
         onChange={onChange}
         postTypes={fieldDef.post_type || ['person', 'company']}
         max={fieldDef.max || 0}
       />
     )}
   />
   ```
   - Search input with autocomplete
   - Show selected items with remove button
   - Use prmApi.search for autocomplete

4. **Form submission**:
   - Build updated values object
   - Handle image/file upload if changed
   - Call onSubmit with values
   - onSubmit should merge into existing ACF and save via wpApi.updatePerson/Company

5. **Reset on open**:
   ```jsx
   useEffect(() => {
     if (isOpen) {
       reset(buildDefaultValues(fieldDefs, currentValues));
     }
   }, [isOpen, fieldDefs, currentValues, reset]);
   ```
  </action>
  <verify>
- Modal opens and closes properly
- All field types render correct inputs
- Form submits with correct data structure
- Image/file upload works
- Color picker works
- Relationship search works
  </verify>
  <done>
- CustomFieldsEditModal component created at src/components/CustomFieldsEditModal.jsx
- Supports all 14 field types with appropriate inputs
- Follows modal pattern from ContactEditModal
- Handles file uploads and complex field types
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate CustomFieldsSection into PersonDetail and CompanyDetail</name>
  <files>src/pages/People/PersonDetail.jsx, src/pages/Companies/CompanyDetail.jsx</files>
  <action>
Add the CustomFieldsSection component to both detail pages.

**PersonDetail.jsx:**

1. Add import at top of file:
   ```jsx
   import CustomFieldsSection from '@/components/CustomFieldsSection';
   ```

2. Add state for tracking custom fields update:
   The component already has `updatePerson` mutation - use it directly.

3. Add section in Profile tab, after the Relationships section (around line 2155):
   ```jsx
   {/* Custom Fields - after Relationships section */}
   <CustomFieldsSection
     postType="person"
     postId={parseInt(id)}
     acfData={person?.acf}
     onUpdate={(newAcfValues) => {
       const acfData = sanitizePersonAcf(person.acf, newAcfValues);
       updatePerson.mutateAsync({
         id,
         data: { acf: acfData },
       });
     }}
     isUpdating={updatePerson.isPending}
   />
   ```

   Place it at the END of the Profile tab's columns div, so it appears after Relationships.

**CompanyDetail.jsx:**

1. Add import at top:
   ```jsx
   import CustomFieldsSection from '@/components/CustomFieldsSection';
   ```

2. Add mutation for updating company if not exists - check if `updateCompany` mutation exists, if not add it similar to PersonDetail pattern

3. Add section after the main company info, in appropriate location:
   ```jsx
   <CustomFieldsSection
     postType="company"
     postId={parseInt(id)}
     acfData={company?.acf}
     onUpdate={(newAcfValues) => {
       // Update company ACF
       updateCompany.mutateAsync({
         id,
         data: { acf: { ...company?.acf, ...newAcfValues } },
       });
     }}
     isUpdating={updateCompany?.isPending}
   />
   ```

Note: CompanyDetail structure is different from PersonDetail - check where sections are placed and add Custom Fields in a logical location (after the main company info cards).
  </action>
  <verify>
- PersonDetail shows Custom Fields section when fields are defined for person
- CompanyDetail shows Custom Fields section when fields are defined for company
- Sections don't appear when no custom fields defined
- Editing works and saves values correctly
- Build passes: `npm run build`
  </verify>
  <done>
- CustomFieldsSection integrated into PersonDetail.jsx
- CustomFieldsSection integrated into CompanyDetail.jsx
- Sections appear in appropriate locations
- Edit functionality works for both post types
  </done>
</task>

</tasks>

<verification>
1. Person detail view shows "Custom fields" section with all defined person fields
2. Organization detail view shows "Custom fields" section with all defined company fields
3. Each field type displays appropriately (dates formatted, colors as swatches, etc.)
4. Edit modal opens with all fields editable
5. Save persists values and refreshes display
6. Section hidden when no custom fields defined
7. Build passes: `npm run build`
</verification>

<success_criteria>
- DISP-01: Custom Fields section on Person detail view - DONE
- DISP-02: Custom Fields section on Organization detail view - DONE
- DISP-03: Inline editing of custom field values (via modal) - DONE
- DISP-04: Type-appropriate rendering - DONE
</success_criteria>

<output>
After completion, create `.planning/phases/91-detail-view-integration/91-02-SUMMARY.md`
</output>
