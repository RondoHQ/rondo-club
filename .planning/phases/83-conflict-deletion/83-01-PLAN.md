---
phase: 83-conflict-deletion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-google-contacts-api-import.php
  - includes/class-google-contacts-sync.php
autonomous: true

must_haves:
  truths:
    - "When same field is modified in both Stadion and Google, conflict is detected"
    - "Stadion value is kept, Google value is discarded"
    - "Conflict resolution is logged as activity entry on the person"
    - "Activity entry shows field name and both values"
  artifacts:
    - path: "includes/class-google-contacts-api-import.php"
      provides: "Field snapshot storage, conflict detection, activity logging"
      contains: "_google_synced_fields"
    - path: "includes/class-google-contacts-sync.php"
      provides: "Snapshot update after push phase"
      contains: "update_field_snapshot"
  key_links:
    - from: "import_delta()"
      to: "detect_field_conflicts()"
      via: "Called during contact processing"
      pattern: "detect_field_conflicts"
    - from: "detect_field_conflicts()"
      to: "wp_insert_comment"
      via: "Activity logging"
      pattern: "TYPE_ACTIVITY"
---

<objective>
Add field-level conflict detection and resolution to Google Contacts sync.

Purpose: When a contact is modified in both Stadion and Google between syncs, detect which specific fields conflict, automatically resolve by keeping Stadion values (Stadion is source of truth), and log the resolution as an activity entry for audit.

Output: Modified import class with conflict detection logic, field snapshot storage, and activity logging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/83-conflict-deletion/83-CONTEXT.md
@.planning/phases/83-conflict-deletion/83-RESEARCH.md
@.planning/phases/82-delta-sync/82-02-SUMMARY.md

@includes/class-google-contacts-api-import.php
@includes/class-google-contacts-sync.php
@includes/class-comment-types.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add field snapshot storage and conflict detection</name>
  <files>includes/class-google-contacts-api-import.php</files>
  <action>
Add field snapshot storage and conflict detection to GoogleContactsAPI class:

1. Add new private method `get_field_snapshot(int $post_id): array` that extracts current Stadion field values:
   - first_name: `get_field('first_name', $post_id)`
   - last_name: `get_field('last_name', $post_id)`
   - email: primary email from contact_info repeater (first email type entry)
   - phone: primary phone from contact_info repeater (first phone/mobile type entry)
   - team: current job team name from work_history (first entry with is_current=true or first entry)

2. Add new private method `store_field_snapshot(int $post_id): void`:
   - Get current field values via `get_field_snapshot()`
   - Add `synced_at` timestamp: `current_time('c')`
   - Store as `update_post_meta($post_id, '_google_synced_fields', $snapshot)`

3. Add new private method `detect_field_conflicts(int $post_id, object $google_person): array`:
   - Get stored snapshot: `get_post_meta($post_id, '_google_synced_fields', true) ?: []`
   - Get current Stadion values via `get_field_snapshot()`
   - Extract Google values from person object (reuse existing extraction logic)
   - For each field, check: `$google_value !== $snapshot_value && $stadion_value !== $snapshot_value`
     - If true: both systems changed this field = conflict
     - Add to conflicts array: `['field' => $field_name, 'google_value' => $gv, 'stadion_value' => $cv, 'kept_value' => $cv]`
   - Return conflicts array

4. Add new private method `log_conflict_resolution(int $post_id, array $conflicts): void`:
   - If conflicts is empty, return early
   - Format content as bullet list:
     ```
     Sync conflict resolved (Stadion wins):
     - First name: Google had "John", kept "Jonathan"
     - Email: Google had "old@email.com", kept "new@email.com"
     ```
   - Use `wp_insert_comment()` with:
     - `comment_post_ID` => $post_id
     - `comment_content` => formatted content
     - `comment_type` => `CommentTypes::TYPE_ACTIVITY` (use the constant)
     - `user_id` => $this->user_id
     - `comment_approved` => 1
   - Add meta: `update_comment_meta($comment_id, 'activity_type', 'sync_conflict')`
   - Add meta: `update_comment_meta($comment_id, 'activity_date', current_time('Y-m-d'))`

5. Modify `process_contact()` method:
   - After `$existing_id = $this->find_by_email($email)` and before any field imports
   - If `$existing_id` (updating existing contact), call `detect_field_conflicts($existing_id, $person)`
   - If conflicts found, call `log_conflict_resolution($existing_id, $conflicts)`
   - Note: Do NOT skip field imports - Stadion wins means we keep Stadion values, but fill-gaps-only import logic already preserves existing Stadion values

6. Modify `store_google_ids()` method:
   - After storing google IDs, call `$this->store_field_snapshot($post_id)`
   - This ensures snapshot is updated after every successful import

Add use statement at top: `use Stadion\Collaboration\CommentTypes;`

IMPORTANT: The fill-gaps-only import logic already preserves Stadion values (it only fills empty fields). Conflict detection is about LOGGING when Google had a different value, not about changing resolution behavior.
  </action>
  <verify>
Run syntax check: `php -l includes/class-google-contacts-api-import.php` returns no errors.

Verify the new methods exist by grepping:
- `grep -n "detect_field_conflicts" includes/class-google-contacts-api-import.php`
- `grep -n "_google_synced_fields" includes/class-google-contacts-api-import.php`
- `grep -n "log_conflict_resolution" includes/class-google-contacts-api-import.php`
  </verify>
  <done>
GoogleContactsAPI class has:
- Field snapshot storage in `_google_synced_fields` post meta
- `detect_field_conflicts()` method comparing Google vs Stadion vs snapshot
- `log_conflict_resolution()` method creating activity entries
- Conflict detection called during `process_contact()` for existing contacts
- Snapshot updated after every successful sync in `store_google_ids()`
  </done>
</task>

<task type="auto">
  <name>Task 2: Add snapshot update after push phase</name>
  <files>includes/class-google-contacts-sync.php</files>
  <action>
Update GoogleContactsSync to update field snapshots after push phase:

1. Add new public static method `update_field_snapshot(int $post_id): void`:
   - This is a wrapper that can be called from export class
   - Get field values (same structure as import class):
     - first_name, last_name from ACF fields
     - email: primary email from contact_info repeater
     - phone: primary phone from contact_info repeater
     - team: current job team name
   - Add synced_at timestamp
   - Store as `update_post_meta($post_id, '_google_synced_fields', $snapshot)`

2. In `push_changed_contacts()` method, after successful `$exporter->export_contact($post->ID)`:
   - Call `self::update_field_snapshot($post->ID)`
   - This ensures snapshot is updated after successful export to Google

The snapshot must be updated after BOTH import (already done in Task 1) AND export, so that subsequent conflict detection has accurate "last synced" values.
  </action>
  <verify>
Run syntax check: `php -l includes/class-google-contacts-sync.php` returns no errors.

Verify the method exists: `grep -n "update_field_snapshot" includes/class-google-contacts-sync.php`
  </verify>
  <done>
GoogleContactsSync class has:
- `update_field_snapshot()` static method for storing field snapshots
- Snapshot updated after every successful export in `push_changed_contacts()`
- Bidirectional snapshot updates ensure accurate conflict detection
  </done>
</task>

<task type="auto">
  <name>Task 3: Build, deploy, and verify</name>
  <files>dist/</files>
  <action>
1. Build the frontend (ensures dist/ is up to date):
   ```bash
   cd /Users/joostdevalk/Code/stadion && npm run build
   ```

2. Deploy to production:
   ```bash
   # Sync dist folder
   rsync -avz --delete -e "ssh -p 18765" /Users/joostdevalk/Code/stadion/dist/ u25-eninwxjgiulh@c1130624.sgvps.net:~/www/cael.is/public_html/wp-content/themes/stadion/dist/

   # Sync theme files
   rsync -avz --exclude='.git' --exclude='node_modules' --exclude='dist' -e "ssh -p 18765" /Users/joostdevalk/Code/stadion/ u25-eninwxjgiulh@c1130624.sgvps.net:~/www/cael.is/public_html/wp-content/themes/stadion/

   # Clear caches
   ssh u25-eninwxjgiulh@c1130624.sgvps.net -p 18765 "cd ~/www/cael.is/public_html && wp cache flush && wp sg purge"
   ```

3. Verify PHP syntax on production:
   ```bash
   ssh u25-eninwxjgiulh@c1130624.sgvps.net -p 18765 "php -l ~/www/cael.is/public_html/wp-content/themes/stadion/includes/class-google-contacts-api-import.php && php -l ~/www/cael.is/public_html/wp-content/themes/stadion/includes/class-google-contacts-sync.php"
   ```
  </action>
  <verify>
All PHP files pass syntax check on production. Cache is cleared. Production site loads without errors.
  </verify>
  <done>
Conflict detection and resolution code deployed to production. Field snapshots will be stored on next sync, enabling conflict detection on subsequent syncs.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Code review:
   - `_google_synced_fields` meta key used for snapshot storage
   - `detect_field_conflicts()` compares all three values (Google, Stadion, snapshot)
   - `log_conflict_resolution()` creates TYPE_ACTIVITY comment with sync_conflict type
   - Snapshot updated after both import and export

2. Integration verification:
   - Next sync will store field snapshots for all synced contacts
   - Subsequent syncs will detect conflicts by comparing against stored snapshots
   - Conflicts logged as activity entries visible in person timeline
</verification>

<success_criteria>
- [ ] `detect_field_conflicts()` method exists and compares Google vs Stadion vs snapshot
- [ ] `log_conflict_resolution()` creates activity entry with TYPE_ACTIVITY
- [ ] Field snapshot stored after import in `store_google_ids()`
- [ ] Field snapshot stored after export in `push_changed_contacts()`
- [ ] All PHP files pass syntax check
- [ ] Code deployed to production
</success_criteria>

<output>
After completion, create `.planning/phases/83-conflict-deletion/83-01-SUMMARY.md`
</output>
