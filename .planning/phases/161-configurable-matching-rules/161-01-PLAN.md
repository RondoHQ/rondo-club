---
phase: 161-configurable-matching-rules
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-membership-fees.php
  - includes/class-rest-api.php
autonomous: true

must_haves:
  truths:
    - "Category objects in WordPress options can contain matching_teams (array of team post IDs) and matching_werkfuncties (array of strings)"
    - "calculate_fee() assigns 'recreant' category based on matching_teams config instead of hardcoded is_recreational_team() string matching"
    - "calculate_fee() assigns 'donateur' category based on matching_werkfuncties config instead of hardcoded is_donateur() check"
    - "Existing fee calculations produce identical results after migration — existing 'recreant' categories pre-populated with recreational team IDs, 'donateur' with ['Donateur']"
    - "REST API validation accepts matching_teams (array of integers) and matching_werkfuncties (array of strings) in category objects"
    - "A new endpoint returns distinct werkfunctie values from the database for the UI multi-select"
  artifacts:
    - path: "includes/class-membership-fees.php"
      provides: "Config-driven matching in calculate_fee(), migration helper, team/werkfunctie matching methods"
      contains: "get_category_by_team_match"
    - path: "includes/class-rest-api.php"
      provides: "Validation for matching_teams and matching_werkfuncties fields, werkfuncties endpoint"
      contains: "get_available_werkfuncties"
  key_links:
    - from: "includes/class-membership-fees.php"
      to: "WordPress options (rondo_membership_fees_{season})"
      via: "get_categories_for_season() → maybe_migrate_matching_rules()"
      pattern: "maybe_migrate_matching_rules"
    - from: "includes/class-membership-fees.php calculate_fee()"
      to: "includes/class-membership-fees.php get_category_by_team_match()"
      via: "Config-driven team matching replaces hardcoded is_recreational_team()"
      pattern: "get_category_by_team_match"
    - from: "includes/class-rest-api.php validate_category_config()"
      to: "matching_teams and matching_werkfuncties fields"
      via: "Type validation for new optional fields"
      pattern: "matching_teams"
---

<objective>
Add configurable matching rules (teams, werkfuncties) to the fee category data model, rewrite calculate_fee() to use config-driven matching instead of hardcoded helpers, and extend REST API validation.

Purpose: Replaces the last hardcoded fee logic (is_recreational_team() and is_donateur()) with admin-configurable per-category matching rules, completing v21.0's goal of fully configurable fee categories.

Output: Updated MembershipFees class with config-driven matching, migration logic for existing categories, REST API validation for new fields, and a werkfuncties endpoint for the settings UI.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/161-configurable-matching-rules/161-RESEARCH.md
@includes/class-membership-fees.php
@includes/class-rest-api.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend MembershipFees with matching rules migration and config-driven calculate_fee()</name>
  <files>includes/class-membership-fees.php</files>
  <action>
  In `class-membership-fees.php`, make the following changes:

  **1. Add `maybe_migrate_matching_rules()` method** (called from `get_categories_for_season()`):
  - Detect categories missing `matching_teams` or `matching_werkfuncties` keys
  - If slug is 'recreant' and `matching_teams` is missing: call `find_recreational_team_ids()` to populate from current teams in the database
  - If slug is 'donateur' and `matching_werkfuncties` is missing: populate with `['Donateur']`
  - For all other categories missing these keys: set empty arrays `[]`
  - Return the migrated array. Only persist (save) if migration actually changed anything.

  **2. Add `find_recreational_team_ids()` private helper:**
  - Query all team posts using WP_Query (post_type 'team', posts_per_page -1)
  - Filter using existing `is_recreational_team()` method to find matching team IDs
  - Return array of integer team post IDs

  **3. Add `get_category_by_team_match()` private method:**
  - Takes `array $team_ids` (person's current team IDs) and optional `?string $season`
  - Gets categories for season, sorts by sort_order (lowest first)
  - Iterates categories; for each with non-empty `matching_teams` array, checks if any of person's team IDs are in the category's matching_teams
  - Filter out invalid team IDs: use `get_post_status()` to skip deleted teams (status not 'publish')
  - Returns first matching category slug, or null

  **4. Add `get_category_by_werkfunctie_match()` private method:**
  - Takes `array $werkfuncties` (person's werkfuncties) and optional `?string $season`
  - Gets categories for season, sorts by sort_order (lowest first)
  - Iterates categories; for each with non-empty `matching_werkfuncties` array, checks if any of person's werkfuncties match (using `strcasecmp()` for case-insensitive comparison, `trim()` both sides)
  - Returns first matching category slug, or null

  **5. Rewrite `calculate_fee()` (lines 383-469):**
  Replace the current hardcoded logic with this flow:
  1. Get `leeftijdsgroep` and attempt age class match (unchanged)
  2. If youth category matched → return immediately (unchanged priority)
  3. Get person's current teams via `get_current_teams()`
  4. Check team matching: call `get_category_by_team_match($teams, $season)`
     - If a team-matched category is found → return it
  5. Get person's werkfuncties via `get_field('werkfuncties', $person_id)`
  6. Check werkfunctie matching: call `get_category_by_werkfunctie_match($werkfuncties, $season)`
     - If a werkfunctie-matched category is found → return it
  7. If we had an age-class match (non-youth, e.g., 'senior'): return it as fallback
  8. Otherwise return null (no valid category)

  This preserves the existing priority: youth > team matching > werkfunctie matching > age-class fallback.

  **IMPORTANT behavioral preservation notes:**
  - The current logic checks if ALL teams are recreational before assigning 'recreant'. The new config-driven logic should match if ANY of person's teams appears in a category's matching_teams. This is correct because the admin explicitly selects which teams map to which categories.
  - The current donateur logic requires "exactly one werkfunctie and it's Donateur". The new config-driven logic matches if ANY werkfunctie matches. This is more flexible and correct for the configurable model.
  - Keep `is_recreational_team()` and `is_donateur()` as private methods (used by migration logic). Mark them with `@deprecated` PHPDoc tag.

  **6. Update `get_categories_for_season()` (line 587-620):**
  After the existing `maybe_migrate_age_classes()` call, also call `maybe_migrate_matching_rules()`:
  ```php
  $migrated = $this->maybe_migrate_age_classes( $stored );
  $migrated = $this->maybe_migrate_matching_rules( $migrated );
  ```
  Apply same pattern in the copy-forward branch (line 612).
  </action>
  <verify>
  - Read the updated file to verify all methods are present and correctly structured
  - Verify calculate_fee() no longer has hardcoded 'recreant'/'donateur'/'senior' slug checks
  - Verify maybe_migrate_matching_rules() populates defaults for recreant and donateur
  - Verify is_recreational_team() and is_donateur() are marked @deprecated
  </verify>
  <done>
  - calculate_fee() uses get_category_by_team_match() and get_category_by_werkfunctie_match() instead of hardcoded is_recreational_team()/is_donateur() checks
  - maybe_migrate_matching_rules() auto-populates matching_teams for 'recreant' and matching_werkfuncties for 'donateur' on first load
  - All new methods have proper PHPDoc
  - Existing priority (youth > team > werkfunctie > age-class) is preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend REST API validation and add werkfuncties endpoint</name>
  <files>includes/class-rest-api.php</files>
  <action>
  In `class-rest-api.php`, make the following changes:

  **1. Add werkfuncties endpoint registration** (in `register_routes()`):
  Register a new GET endpoint at `rondo/v1/werkfuncties/available`:
  ```php
  register_rest_route(
      'rondo/v1',
      '/werkfuncties/available',
      [
          'methods'             => \WP_REST_Server::READABLE,
          'callback'            => [ $this, 'get_available_werkfuncties' ],
          'permission_callback' => [ $this, 'check_admin_permission' ],
      ]
  );
  ```

  **2. Add `get_available_werkfuncties()` callback:**
  Query distinct werkfunctie values from the database. The `werkfuncties` ACF field is stored as serialized data in postmeta. Use a direct DB query similar to the volunteer roles pattern:
  ```php
  global $wpdb;
  // werkfuncties is stored as a serialized array in the 'werkfuncties' meta key
  $results = $wpdb->get_col(
      "SELECT DISTINCT pm.meta_value
       FROM {$wpdb->postmeta} pm
       INNER JOIN {$wpdb->posts} p ON p.ID = pm.post_id
       WHERE pm.meta_key = 'werkfuncties'
       AND pm.meta_value != ''
       AND pm.meta_value NOT LIKE 'a:%'
       AND p.post_type = 'person'
       AND p.post_status = 'publish'
       ORDER BY pm.meta_value ASC"
  );
  ```
  However, werkfuncties is likely stored as a serialized array. If so, we need to unserialize and collect unique values. Better approach: since werkfuncties is an ACF repeater or select field, check how it's stored. Based on the codebase (`get_field('werkfuncties', $person_id)` returns an array), it's likely stored as a serialized array. The simplest approach is:
  - Query all people who have a `werkfuncties` meta value
  - Unserialize each, collect unique values
  - Sort and return

  Use this implementation:
  ```php
  public function get_available_werkfuncties( $request ) {
      $people = get_posts([
          'post_type'      => 'person',
          'post_status'    => 'publish',
          'posts_per_page' => -1,
          'fields'         => 'ids',
          'meta_query'     => [
              [
                  'key'     => 'werkfuncties',
                  'compare' => 'EXISTS',
              ],
          ],
      ]);

      $all_werkfuncties = [];
      foreach ( $people as $person_id ) {
          $werkfuncties = get_field( 'werkfuncties', $person_id ) ?: [];
          foreach ( $werkfuncties as $wf ) {
              if ( is_string( $wf ) && trim( $wf ) !== '' ) {
                  $all_werkfuncties[ trim( $wf ) ] = true;
              }
          }
      }

      $unique = array_keys( $all_werkfuncties );
      sort( $unique );

      return rest_ensure_response( $unique );
  }
  ```

  **3. Extend `validate_category_config()` (around line 2754, before the closing of the foreach):**
  Add validation for the two new optional fields after the age_classes validation block:

  ```php
  // Validate matching_teams (optional, must be array of integers if present)
  if ( isset( $category['matching_teams'] ) ) {
      if ( ! is_array( $category['matching_teams'] ) ) {
          $errors[] = [
              'field'   => "categories.{$slug}.matching_teams",
              'message' => 'matching_teams must be an array',
          ];
      } else {
          foreach ( $category['matching_teams'] as $team_id ) {
              if ( ! is_numeric( $team_id ) || (int) $team_id <= 0 ) {
                  $errors[] = [
                      'field'   => "categories.{$slug}.matching_teams",
                      'message' => 'matching_teams must contain valid team IDs (positive integers)',
                  ];
                  break;
              }
          }
      }
  }

  // Validate matching_werkfuncties (optional, must be array of strings if present)
  if ( isset( $category['matching_werkfuncties'] ) ) {
      if ( ! is_array( $category['matching_werkfuncties'] ) ) {
          $errors[] = [
              'field'   => "categories.{$slug}.matching_werkfuncties",
              'message' => 'matching_werkfuncties must be an array',
          ];
      } else {
          foreach ( $category['matching_werkfuncties'] as $wf ) {
              if ( ! is_string( $wf ) || trim( $wf ) === '' ) {
                  $errors[] = [
                      'field'   => "categories.{$slug}.matching_werkfuncties",
                      'message' => 'matching_werkfuncties must contain non-empty strings',
                  ];
                  break;
              }
          }
      }
  }
  ```
  </action>
  <verify>
  - Read the updated file to verify the new endpoint registration and callback
  - Verify validate_category_config() includes matching_teams and matching_werkfuncties validation
  - Verify the werkfuncties endpoint is registered with admin permission
  </verify>
  <done>
  - GET /rondo/v1/werkfuncties/available endpoint returns distinct werkfunctie values from all people
  - validate_category_config() validates matching_teams as array of positive integers and matching_werkfuncties as array of non-empty strings
  - Both new fields are optional (existing categories without them still pass validation)
  </done>
</task>

</tasks>

<verification>
1. Read includes/class-membership-fees.php and verify:
   - maybe_migrate_matching_rules() exists and handles recreant/donateur defaults
   - get_category_by_team_match() and get_category_by_werkfunctie_match() exist
   - calculate_fee() uses new methods instead of hardcoded is_recreational_team()/is_donateur()
   - is_recreational_team() and is_donateur() have @deprecated tags
2. Read includes/class-rest-api.php and verify:
   - werkfuncties/available route is registered
   - get_available_werkfuncties() callback exists
   - validate_category_config() validates matching_teams and matching_werkfuncties
3. Build frontend with `npm run build` to ensure no PHP syntax errors break the build process
</verification>

<success_criteria>
- calculate_fee() is fully config-driven: no hardcoded category slug checks for 'recreant', 'donateur', or 'senior'
- Existing categories auto-migrate: 'recreant' gets matching_teams populated from recreational team IDs, 'donateur' gets matching_werkfuncties=['Donateur']
- REST API validation accepts and validates matching_teams and matching_werkfuncties on category objects
- GET /rondo/v1/werkfuncties/available returns distinct werkfunctie values for UI multi-select
</success_criteria>

<output>
After completion, create `.planning/phases/161-configurable-matching-rules/161-01-SUMMARY.md`
</output>
