---
phase: 139-backend-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-access-control.php
  - includes/class-rest-api.php
  - includes/class-wp-cli.php
autonomous: true

must_haves:
  truths:
    - "User A cannot see tasks created by User B in the Tasks list page"
    - "User A cannot see User B's tasks in any PersonDetail sidebar"
    - "User A cannot see User B's tasks in the GlobalTodoModal"
    - "Dashboard open todos count reflects only current user's tasks"
    - "Dashboard awaiting todos count reflects only current user's tasks"
    - "WP-CLI command can verify task ownership without making changes"
    - "WP-CLI command can fix task ownership with dry-run support"
  artifacts:
    - path: "includes/class-access-control.php"
      provides: "Author filtering for stadion_todo queries"
      contains: "author.*get_current_user_id"
    - path: "includes/class-rest-api.php"
      provides: "User-filtered dashboard todo counts"
      contains: "post_author.*get_current_user_id"
    - path: "includes/class-wp-cli.php"
      provides: "Task ownership migration command"
      contains: "fix_ownership"
  key_links:
    - from: "includes/class-access-control.php"
      to: "WP_Query"
      via: "filter_queries sets author parameter"
      pattern: "query->set.*author"
    - from: "includes/class-access-control.php"
      to: "REST API"
      via: "filter_rest_query sets author parameter"
      pattern: "args\\[.author.\\]"
    - from: "includes/class-rest-api.php"
      to: "Database"
      via: "Direct SQL query with post_author filter"
      pattern: "wpdb->get_var.*post_author"
---

<objective>
Implement user isolation for tasks by filtering queries based on post_author and updating dashboard counts to show only the current user's tasks.

Purpose: Transform tasks from shared visibility to personal isolation - each user only sees tasks they created while maintaining multi-person linking capability for context.

Output:
- Access control filters tasks by post_author across all query methods
- Dashboard shows accurate counts for current user only
- WP-CLI command available to verify and fix task ownership
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/139-backend-migration/139-RESEARCH.md
@includes/class-access-control.php
@includes/class-rest-api.php
@includes/class-wp-cli.php
@includes/class-rest-todos.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add author filtering to AccessControl for stadion_todo</name>
  <files>includes/class-access-control.php</files>
  <action>
Modify the AccessControl class to filter stadion_todo posts by post_author:

1. In `filter_queries()` method (around line 188, after the VOG-only filtering):
   - Add condition: if post_type is 'stadion_todo', set author to current user ID
   - Insert AFTER the is_user_approved check (unapproved users already blocked)
   - Insert BEFORE the VOG-only filtering (that only applies to 'person' type)

   Code to add:
   ```php
   // User isolation for tasks - users only see their own tasks
   if ( $post_type === 'stadion_todo' ) {
       $query->set( 'author', get_current_user_id() );
   }
   ```

2. In `filter_rest_query()` method (around line 213):
   - Add the same author filtering for stadion_todo
   - This filter receives the current hook name which indicates post type
   - Add after the approval check, before returning $args

   Code to add:
   ```php
   // User isolation for tasks - users only see their own tasks
   // Check if this is a stadion_todo query by examining current filter
   $current_filter = current_filter();
   if ( $current_filter === 'rest_stadion_todo_query' ) {
       $args['author'] = get_current_user_id();
   }
   ```

Note: Do NOT add special handling for admins - per RESEARCH.md, task isolation applies to all users including admins.
  </action>
  <verify>
Verify changes with grep:
- `grep -n "stadion_todo" includes/class-access-control.php` should show new filtering logic
- `grep -n "author.*get_current_user_id" includes/class-access-control.php` should show both filter methods
  </verify>
  <done>
- filter_queries() sets author parameter for stadion_todo post type
- filter_rest_query() sets author parameter for rest_stadion_todo_query filter
- No special admin exemption (all users see only their own tasks)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update dashboard todo counts to filter by current user</name>
  <files>includes/class-rest-api.php</files>
  <action>
Replace wp_count_posts() calls with author-filtered SQL queries:

1. Modify `count_open_todos()` method (around line 2045):
   - Replace `wp_count_posts('stadion_todo')->stadion_open ?? 0`
   - Use direct $wpdb query that filters by post_author

   New implementation:
   ```php
   private function count_open_todos() {
       global $wpdb;
       return (int) $wpdb->get_var( $wpdb->prepare(
           "SELECT COUNT(*) FROM {$wpdb->posts}
            WHERE post_type = %s
            AND post_status = %s
            AND post_author = %d",
           'stadion_todo',
           'stadion_open',
           get_current_user_id()
       ) );
   }
   ```

2. Modify `count_awaiting_todos()` method (around line 2128):
   - Same pattern as above, but for stadion_awaiting status

   New implementation:
   ```php
   private function count_awaiting_todos() {
       global $wpdb;
       return (int) $wpdb->get_var( $wpdb->prepare(
           "SELECT COUNT(*) FROM {$wpdb->posts}
            WHERE post_type = %s
            AND post_status = %s
            AND post_author = %d",
           'stadion_todo',
           'stadion_awaiting',
           get_current_user_id()
       ) );
   }
   ```

Note: Using direct SQL is appropriate here because:
- count_user_posts() doesn't support custom post statuses
- This is a simple COUNT query with indexed columns (post_type, post_status, post_author)
- The query is prepared to prevent SQL injection
  </action>
  <verify>
Verify changes with grep:
- `grep -n "wpdb->get_var" includes/class-rest-api.php` should show both count methods using prepared queries
- `grep -n "post_author.*get_current_user_id" includes/class-rest-api.php` should show both methods filtering by author
- `grep -n "wp_count_posts.*stadion_todo" includes/class-rest-api.php` should return nothing (old code removed)
  </verify>
  <done>
- count_open_todos() uses SQL query with post_author filter
- count_awaiting_todos() uses SQL query with post_author filter
- No references to wp_count_posts('stadion_todo') remain
  </done>
</task>

<task type="auto">
  <name>Task 3: Create WP-CLI migration command for task ownership</name>
  <files>includes/class-wp-cli.php</files>
  <action>
Add a new WP-CLI command class for task-related commands. Following the existing pattern in class-wp-cli.php:

1. Create a new command class `RONDO_Tasks_CLI_Command` near the end of the file (before the final WP_CLI::add_command calls):

```php
/**
 * Tasks WP-CLI Commands
 */
class RONDO_Tasks_CLI_Command {

    /**
     * Verify or fix task ownership
     *
     * Ensures all stadion_todo posts have valid post_author.
     * Tasks with invalid authors can be fixed by inferring from related persons.
     *
     * ## OPTIONS
     *
     * [--verify]
     * : Only verify ownership, report issues without fixing
     *
     * [--dry-run]
     * : Show what would be fixed without making changes
     *
     * ## EXAMPLES
     *
     *     wp stadion tasks verify-ownership --verify
     *     wp stadion tasks verify-ownership --dry-run
     *     wp stadion tasks verify-ownership
     *
     * @when after_wp_load
     */
    public function verify_ownership( $args, $assoc_args ) {
        $verify  = isset( $assoc_args['verify'] );
        $dry_run = isset( $assoc_args['dry-run'] );

        if ( $dry_run ) {
            WP_CLI::log( 'DRY RUN MODE - No changes will be made' );
        }

        WP_CLI::log( '' );
        WP_CLI::log( '╔════════════════════════════════════════════════════════════╗' );
        WP_CLI::log( '║         Task Ownership Verification                        ║' );
        WP_CLI::log( '╚════════════════════════════════════════════════════════════╝' );
        WP_CLI::log( '' );

        // Query all stadion_todo posts, bypass access control
        $todos = get_posts( [
            'post_type'        => 'stadion_todo',
            'posts_per_page'   => -1,
            'post_status'      => [ 'stadion_open', 'stadion_awaiting', 'stadion_completed', 'publish' ],
            'suppress_filters' => true,
        ] );

        if ( empty( $todos ) ) {
            WP_CLI::success( 'No tasks found in the system.' );
            return;
        }

        WP_CLI::log( sprintf( 'Found %d task(s) to check.', count( $todos ) ) );
        WP_CLI::log( '' );

        $valid   = 0;
        $invalid = 0;
        $fixed   = 0;
        $failed  = 0;

        foreach ( $todos as $todo ) {
            $author_id = (int) $todo->post_author;
            $user      = get_userdata( $author_id );

            if ( $user && $author_id > 0 ) {
                if ( ! $verify && ! $dry_run ) {
                    // Silent in fix mode for valid tasks
                } else {
                    WP_CLI::log( sprintf( '  ✓ Task #%d: %s (author: %s, ID: %d)',
                        $todo->ID,
                        wp_trim_words( $todo->post_title, 8 ),
                        $user->user_login,
                        $author_id
                    ) );
                }
                $valid++;
            } else {
                WP_CLI::warning( sprintf( '  ✗ Task #%d has invalid author ID: %d', $todo->ID, $author_id ) );
                $invalid++;

                if ( ! $verify ) {
                    // Attempt to determine correct author from related_persons
                    $person_ids = get_field( 'related_persons', $todo->ID );
                    if ( ! is_array( $person_ids ) ) {
                        $person_ids = $person_ids ? [ $person_ids ] : [];
                    }

                    if ( empty( $person_ids ) ) {
                        WP_CLI::warning( sprintf( '    Cannot fix: No related persons found' ) );
                        $failed++;
                        continue;
                    }

                    // Use the first related person's author
                    $person_id = (int) $person_ids[0];
                    $person    = get_post( $person_id );

                    if ( ! $person ) {
                        WP_CLI::warning( sprintf( '    Cannot fix: Related person #%d not found', $person_id ) );
                        $failed++;
                        continue;
                    }

                    $new_author_id = (int) $person->post_author;
                    $new_user      = get_userdata( $new_author_id );

                    if ( ! $new_user ) {
                        WP_CLI::warning( sprintf( '    Cannot fix: Person #%d has invalid author ID: %d', $person_id, $new_author_id ) );
                        $failed++;
                        continue;
                    }

                    if ( $dry_run ) {
                        WP_CLI::log( sprintf( '    Would set author to: %s (ID: %d)', $new_user->user_login, $new_author_id ) );
                        $fixed++;
                    } else {
                        wp_update_post( [
                            'ID'          => $todo->ID,
                            'post_author' => $new_author_id,
                        ] );
                        WP_CLI::log( sprintf( '    Fixed: Set author to %s (ID: %d)', $new_user->user_login, $new_author_id ) );
                        $fixed++;
                    }
                }
            }
        }

        WP_CLI::log( '' );
        WP_CLI::log( '────────────────────────────────────────────────────────────' );
        WP_CLI::log( 'Summary:' );
        WP_CLI::log( '────────────────────────────────────────────────────────────' );
        WP_CLI::log( sprintf( '  Total tasks: %d', count( $todos ) ) );
        WP_CLI::log( sprintf( '  Valid: %d', $valid ) );
        WP_CLI::log( sprintf( '  Invalid: %d', $invalid ) );

        if ( ! $verify ) {
            WP_CLI::log( sprintf( '  Fixed: %d', $fixed ) );
            WP_CLI::log( sprintf( '  Could not fix: %d', $failed ) );

            if ( $failed > 0 ) {
                WP_CLI::warning( sprintf( 'Completed with %d task(s) that could not be fixed.', $failed ) );
            } else {
                WP_CLI::success( $dry_run ? 'Dry run complete.' : 'All tasks verified/fixed!' );
            }
        } else {
            if ( $invalid > 0 ) {
                WP_CLI::warning( sprintf( 'Found %d task(s) with invalid ownership.', $invalid ) );
                WP_CLI::log( 'Run without --verify to fix.' );
            } else {
                WP_CLI::success( 'All tasks have valid ownership.' );
            }
        }
    }
}
```

2. Register the command near the end of the file with the other WP_CLI::add_command calls:

```php
WP_CLI::add_command( 'stadion tasks', 'RONDO_Tasks_CLI_Command' );
```

Note: The command is named `verify-ownership` (not `fix-ownership`) because its primary purpose is verification, with optional fixing.
  </action>
  <verify>
Verify the command exists and runs:
- `grep -n "RONDO_Tasks_CLI_Command" includes/class-wp-cli.php` should show the class
- `grep -n "stadion tasks" includes/class-wp-cli.php` should show the command registration
- Deploy to production and run: `wp stadion tasks verify-ownership --verify` to test
  </verify>
  <done>
- RONDO_Tasks_CLI_Command class exists with verify_ownership method
- Command registered as 'stadion tasks'
- Supports --verify flag (report only)
- Supports --dry-run flag (show what would change)
- Without flags, actually fixes invalid ownership
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Code verification:**
   - `npm run lint` passes (no PHP errors introduced)
   - `npm run build` succeeds

2. **Deploy to production:**
   - Run `bin/deploy.sh` to deploy changes

3. **Backend verification (via WP-CLI on production):**
   - Run `wp stadion tasks verify-ownership --verify` to check existing tasks
   - Verify command output shows task counts

4. **API verification (test with different users):**
   - User A creates a task, User B should NOT see it in GET /rondo/v1/todos
   - Dashboard counts should reflect only current user's tasks
</verification>

<success_criteria>
Phase 139 requirements covered:

- [x] TASK-01: Tasks list filtered by post_author (via AccessControl.filter_queries)
- [x] TASK-02: PersonDetail sidebar filtered (via AccessControl.filter_queries, get_posts respects filters)
- [x] TASK-03: GlobalTodoModal filtered (via AccessControl.filter_rest_query)
- [x] TASK-04: Dashboard open todos count filtered (count_open_todos uses post_author)
- [x] TASK-05: Dashboard awaiting todos count filtered (count_awaiting_todos uses post_author)
- [x] MIG-01: Existing tasks keep their post_author (no migration needed - tasks already have correct author)
- [x] MIG-02: WP-CLI command to verify/fix ownership (verify-ownership command)
</success_criteria>

<output>
After completion, create `.planning/phases/139-backend-migration/139-01-SUMMARY.md`
</output>
