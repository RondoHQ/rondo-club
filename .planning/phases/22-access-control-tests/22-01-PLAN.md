---
phase: 22-access-control-tests
plan: 01
type: execute
depends_on: []
files_modified: [tests/Wpunit/UserIsolationTest.php]
---

<objective>
Test user isolation - verifying users only see posts they authored.

Purpose: Ensure the fundamental access control rule (users see only their own data) works correctly at both query and single-post levels.
Output: UserIsolationTest.php with comprehensive tests for author-based access control.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-phpunit-setup/21-01-SUMMARY.md

@includes/class-access-control.php
@tests/Support/CaelisTestCase.php
@tests/Wpunit/SmokeTest.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test user_can_access_post() author check</name>
  <files>tests/Wpunit/UserIsolationTest.php</files>
  <action>
Create UserIsolationTest extending CaelisTestCase. Test user_can_access_post() method:

1. Create two Caelis users (Alice, Bob) using createCaelisUser()
2. Approve both users via update_user_meta($user_id, 'caelis_user_approved', '1')
3. Create a person post authored by Alice using createPerson(['post_author' => $alice_id])
4. Get PRM_Access_Control instance (it's instantiated in functions.php, use global or new instance)
5. Test assertions:
   - Alice can access her own post (author check passes)
   - Bob cannot access Alice's post (non-author denied)
   - Test with important_date and company post types as well

Use wp_set_current_user() to switch user context where needed. Ensure tests cover all three controlled post types (person, company, important_date).
  </action>
  <verify>vendor/bin/codecept run Wpunit UserIsolationTest::test_author_can_access_own_post passes</verify>
  <done>Tests verify author always has access, non-author denied for all controlled post types</done>
</task>

<task type="auto">
  <name>Task 2: Test query filtering for user isolation</name>
  <files>tests/Wpunit/UserIsolationTest.php</files>
  <action>
Add tests for get_accessible_post_ids() and query filtering:

1. Create two approved Caelis users
2. Create multiple persons for each user (e.g., 3 for Alice, 2 for Bob)
3. Test get_accessible_post_ids():
   - As Alice, should return only Alice's 3 person IDs
   - As Bob, should return only Bob's 2 person IDs
4. Test WP_Query filtering via filter_queries():
   - Set current user to Alice
   - Query all persons with new WP_Query(['post_type' => 'person', 'posts_per_page' => -1])
   - Assert only Alice's persons returned
5. Test REST query filtering via filter_rest_query():
   - Create mock request args for REST API
   - Call filter_rest_query() directly
   - Assert post__in contains only current user's posts

Also test edge case: not logged in user gets empty results (post__in = [0]).
  </action>
  <verify>vendor/bin/codecept run Wpunit UserIsolationTest passes all tests</verify>
  <done>Query filtering verified for WP_Query, REST API, and logged-out users</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `vendor/bin/codecept run Wpunit UserIsolationTest` passes all tests
- [ ] Tests cover person, company, and important_date post types
- [ ] Tests verify both single-post access and query filtering
- [ ] Tests handle logged-out user scenario
</verification>

<success_criteria>

- All tests pass
- User isolation verified for all three CPTs
- Query filtering works at WP_Query and REST API levels
- Edge cases covered (logged out, non-author)
</success_criteria>

<output>
After completion, create `.planning/phases/22-access-control-tests/22-01-SUMMARY.md`
</output>
