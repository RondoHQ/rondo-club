---
phase: 74-add-person-from-meeting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MeetingDetailModal.jsx
  - src/components/PersonEditModal.jsx
  - src/hooks/usePeople.js
autonomous: true

must_haves:
  truths:
    - "User sees Add button next to unknown meeting attendees"
    - "Clicking Add opens PersonEditModal with name pre-filled from attendee data"
    - "After creating person, attendee list updates to show them as known (accent color, clickable)"
  artifacts:
    - path: "src/components/MeetingDetailModal.jsx"
      provides: "Add button on AttendeeRow, name extraction, PersonEditModal integration"
      contains: "UserPlus"
    - path: "src/components/PersonEditModal.jsx"
      provides: "prefillData prop support for external context pre-filling"
      contains: "prefillData"
    - path: "src/hooks/usePeople.js"
      provides: "Meeting query invalidation on person creation"
      contains: "meetingsKeys"
  key_links:
    - from: "MeetingDetailModal AttendeeRow"
      to: "handleAddPerson callback"
      via: "onClick on UserPlus button"
      pattern: "onAddPerson\\(attendee\\)"
    - from: "MeetingDetailModal"
      to: "PersonEditModal"
      via: "prefillData prop with extracted name/email"
      pattern: "prefillData=\\{personPrefill\\}"
    - from: "useCreatePerson onSuccess"
      to: "meetingsKeys.today"
      via: "queryClient.invalidateQueries"
      pattern: "meetingsKeys\\.today"
---

<objective>
Add person from meeting attendee: User can click Add button next to unknown attendees to create a contact pre-filled with their name and email.

Purpose: Allow quick conversion of unknown meeting attendees into contacts without leaving the meeting modal or manually entering data.
Output: Working add-person flow with name extraction, pre-filled form, and automatic attendee list refresh.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-add-person-from-meeting/74-RESEARCH.md

@src/components/MeetingDetailModal.jsx
@src/components/PersonEditModal.jsx
@src/hooks/usePeople.js
@src/hooks/useMeetings.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prefillData support to PersonEditModal and meeting invalidation to useCreatePerson</name>
  <files>src/components/PersonEditModal.jsx, src/hooks/usePeople.js</files>
  <action>
    **PersonEditModal.jsx changes:**

    1. Add `prefillData = null` prop to the component signature (after `person = null`)

    2. In the useEffect that handles form reset when modal opens, add a third condition for prefillData:
    ```jsx
    } else if (prefillData) {
      // Pre-fill mode - use provided data from external context
      reset({
        first_name: prefillData.first_name || '',
        last_name: prefillData.last_name || '',
        nickname: '',
        gender: '',
        pronouns: '',
        email: prefillData.email || '',
        phone: '',
        phone_type: 'mobile',
        birthday: '',
        how_we_met: '',
        is_favorite: false,
      });
      setVisibility('private');
      setSelectedWorkspaces([]);
    }
    ```

    3. Add `prefillData` to the useEffect dependency array

    **usePeople.js changes:**

    1. Import meetingsKeys at the top:
    ```jsx
    import { meetingsKeys } from './useMeetings';
    ```

    2. In useCreatePerson's onSuccess callback, after the existing invalidations, add:
    ```jsx
    // Invalidate meetings to trigger re-matching of attendees
    queryClient.invalidateQueries({ queryKey: meetingsKeys.today });
    queryClient.invalidateQueries({ queryKey: ['person-meetings'] });
    ```
  </action>
  <verify>
    1. `npm run lint` passes
    2. PersonEditModal accepts prefillData prop and uses it in reset
    3. useCreatePerson imports meetingsKeys and invalidates meeting queries
  </verify>
  <done>
    - PersonEditModal supports prefillData prop for pre-filling form from external context
    - Creating a person invalidates meeting queries so attendee matching updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Add person button and modal integration in MeetingDetailModal</name>
  <files>src/components/MeetingDetailModal.jsx</files>
  <action>
    1. Add imports at the top:
    ```jsx
    import { UserPlus } from 'lucide-react';
    import { useQueryClient } from '@tanstack/react-query';
    import { lazy, Suspense } from 'react';
    import { useCreatePerson } from '@/hooks/usePeople';
    import { meetingsKeys } from '@/hooks/useMeetings';

    const PersonEditModal = lazy(() => import('@/components/PersonEditModal'));
    ```

    2. Add name extraction helper function before the component:
    ```jsx
    /**
     * Extract first/last name from attendee data
     * Handles both display names ("John Doe") and email-only ("john.doe@example.com")
     */
    function extractNameFromAttendee(attendee) {
      // Prefer explicit name over email-derived name
      if (attendee.name && !attendee.name.includes('@')) {
        const parts = attendee.name.trim().split(/\s+/);
        return {
          first_name: parts[0] || '',
          last_name: parts.slice(1).join(' ') || '',
        };
      }

      // Fall back to email local part
      if (attendee.email) {
        const localPart = attendee.email.split('@')[0];
        // Handle john.doe, john_doe, john-doe patterns
        const nameParts = localPart.split(/[._-]/).map(
          part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
        );
        return {
          first_name: nameParts[0] || '',
          last_name: nameParts.slice(1).join(' ') || '',
        };
      }

      return { first_name: '', last_name: '' };
    }
    ```

    3. Add state and handlers inside the MeetingDetailModal component, after the existing state declarations:
    ```jsx
    // Person creation state
    const [showPersonModal, setShowPersonModal] = useState(false);
    const [personPrefill, setPersonPrefill] = useState(null);
    const queryClient = useQueryClient();

    const createPersonMutation = useCreatePerson({
      onSuccess: () => {
        setShowPersonModal(false);
        setPersonPrefill(null);
      },
    });

    // Handle add person button click
    const handleAddPerson = (attendee) => {
      const { first_name, last_name } = extractNameFromAttendee(attendee);
      setPersonPrefill({
        first_name,
        last_name,
        email: attendee.email || '',
      });
      setShowPersonModal(true);
    };

    // Handle person creation submit
    const handleCreatePerson = async (data) => {
      await createPersonMutation.mutateAsync(data);
    };
    ```

    4. Update AttendeeRow function signature to accept `onAddPerson` prop:
    ```jsx
    function AttendeeRow({ attendee, onAddPerson }) {
    ```

    5. In AttendeeRow, after the name/email div and before the closing of the flex container, add the add button:
    ```jsx
    {/* Add button for unmatched attendees */}
    {!attendee.matched && onAddPerson && (
      <button
        onClick={(e) => {
          e.preventDefault();
          e.stopPropagation();
          onAddPerson(attendee);
        }}
        className="flex-shrink-0 p-1.5 text-gray-400 hover:text-accent-600 dark:hover:text-accent-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors"
        title="Add as contact"
      >
        <UserPlus className="w-4 h-4" />
      </button>
    )}
    ```

    6. Update the AttendeeRow usage in the map to pass the handler:
    ```jsx
    {sortedAttendees.map((attendee, index) => (
      <AttendeeRow
        key={attendee.email || index}
        attendee={attendee}
        onAddPerson={handleAddPerson}
      />
    ))}
    ```

    7. Add the PersonEditModal at the end of the component's return, just before the final closing fragment or div:
    ```jsx
    {/* Person creation modal */}
    {showPersonModal && (
      <Suspense fallback={null}>
        <PersonEditModal
          isOpen={showPersonModal}
          onClose={() => {
            setShowPersonModal(false);
            setPersonPrefill(null);
          }}
          onSubmit={handleCreatePerson}
          isLoading={createPersonMutation.isPending}
          prefillData={personPrefill}
        />
      </Suspense>
    )}
    ```

    Note: Ensure the PersonEditModal is rendered OUTSIDE the main modal div but still within the component's return. This allows the z-index stacking to work correctly.
  </action>
  <verify>
    1. `npm run lint` passes
    2. `npm run build` succeeds
    3. Manual test on production:
       - Open a meeting with unknown attendees
       - Verify UserPlus icon appears next to unknown attendees
       - Click add button - PersonEditModal opens with pre-filled name
       - Submit the form - modal closes
       - Attendee list updates to show person as known (accent color, clickable)
  </verify>
  <done>
    - Unknown attendees show Add button (UserPlus icon)
    - Clicking Add opens PersonEditModal pre-filled with extracted name and email
    - After creation, attendee list refreshes to show person as known
  </done>
</task>

</tasks>

<verification>
All requirements covered:

- **ADD-02**: User can click "Add" button next to unknown attendee - UserPlus button on AttendeeRow
- **ADD-03**: New person is pre-filled with name extracted from email - extractNameFromAttendee() utility
- **ADD-04**: After adding, attendee updates to show as known - meetingsKeys.today invalidation in useCreatePerson
</verification>

<success_criteria>
1. `npm run lint` passes with no errors
2. `npm run build` succeeds
3. Unknown attendees display Add button (UserPlus icon on hover)
4. Clicking Add opens PersonEditModal with first_name, last_name, email pre-filled
5. After person creation, meeting modal attendee list shows them as known (accent color, clickable link)
</success_criteria>

<output>
After completion, create `.planning/phases/74-add-person-from-meeting/74-01-SUMMARY.md`
</output>
