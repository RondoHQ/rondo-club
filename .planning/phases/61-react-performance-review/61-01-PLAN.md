---
phase: 61-react-performance-review
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/hooks/*.js, src/pages/**/*.jsx, src/components/**/*.jsx, src/App.jsx, vite.config.js]
autonomous: false
---

<objective>
Analyze the React frontend using the react-best-practices skill and implement fixes for identified performance issues.

Purpose: Optimize render performance, eliminate data fetching waterfalls, and ensure bundle efficiency across the Stadion frontend.
Output: Optimized React codebase with documented performance improvements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

Key files to analyze:
@src/App.jsx
@src/hooks/usePeople.js
@src/hooks/useDashboard.js
@src/hooks/useTheme.js
@src/pages/Dashboard.jsx
@src/pages/People/PersonDetail.jsx
@src/pages/People/PeopleList.jsx
@src/pages/Settings/Settings.jsx
@src/components/PersonEditModal.jsx
@src/components/CompanyEditModal.jsx
@vite.config.js

Current bundle state (from v3.6):
- Main bundle: 50 KB (down from 460 KB)
- Initial page load: ~400 KB (down from ~767 KB)
- Route-based lazy loading implemented
- Modal lazy loading implemented
- Vendor/utils chunking in place
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run react-best-practices skill analysis</name>
  <files>Analysis output - no files modified</files>
  <action>
Invoke the react-best-practices skill to perform comprehensive analysis across:

1. **Render optimization** - Check all components for:
   - Unnecessary re-renders (missing useMemo/useCallback)
   - Inline function definitions in JSX props
   - Missing React.memo on pure presentational components
   - State lifting issues causing cascade re-renders

2. **Data fetching patterns** - Check all hooks and pages for:
   - Request waterfalls (sequential fetches that could be parallel)
   - Missing prefetching opportunities
   - Over-fetching (fetching data not used on current view)
   - Stale query configurations

3. **Bundle efficiency** - Check for:
   - Large components that should be code-split
   - Import patterns pulling in unused code
   - Heavy dependencies that could be lazy-loaded

4. **Component patterns** - Check for:
   - Prop drilling that could use context
   - Duplicated logic across components
   - Missing error boundaries

Focus areas based on current bundle sizes:
- PersonDetail.jsx (144 KB chunk) - largest page component
- Settings.jsx (88 KB chunk) - second largest
- RichTextEditor (364 KB) - already lazy-loaded, verify usage
- TreeVisualization (516 KB) - already lazy-loaded, verify usage

Document all findings with file locations and specific recommendations.
  </action>
  <verify>Analysis complete with categorized list of issues and recommendations</verify>
  <done>Comprehensive performance analysis documented with actionable items</done>
</task>

<task type="auto">
  <name>Task 2: Implement high-impact performance fixes</name>
  <files>src/hooks/*.js, src/pages/**/*.jsx, src/components/**/*.jsx</files>
  <action>
Based on analysis findings, implement fixes prioritized by impact:

**High priority (fix these):**
1. Add useMemo/useCallback where analysis identified unnecessary re-renders
2. Fix any identified request waterfalls by parallelizing fetches
3. Add React.memo to pure presentational components identified as re-rendering excessively
4. Fix any prop drilling issues with context if identified

**Medium priority (fix if straightforward):**
1. Optimize large component chunks if analysis identifies splitting opportunities
2. Add prefetching for common navigation patterns
3. Improve query stale times if over-fetching identified

**Implementation rules:**
- Do NOT break existing functionality
- Keep changes minimal and focused on performance
- Test each fix individually before moving to next
- Document what was changed and why in commit messages

**What NOT to do:**
- Don't refactor code style or naming (this is performance only)
- Don't add new features
- Don't change API contracts
- Don't modify PHP backend
  </action>
  <verify>npm run lint passes, npm run build succeeds</verify>
  <done>High-impact performance fixes implemented, build passes</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Performance optimizations based on react-best-practices analysis</what-built>
  <how-to-verify>
    1. Run: npm run dev
    2. Visit: http://localhost:5173/ (Dashboard)
    3. Navigate to: /people (People list)
    4. Navigate to: /people/{id} (Person detail - test with real person)
    5. Navigate to: /settings (Settings page)
    6. Verify: All pages load correctly, no visual regressions
    7. Verify: No console errors related to the changes
    8. Test: Open React DevTools Profiler, navigate between pages, verify no obvious render storms
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] react-best-practices skill analysis completed
- [ ] High-impact fixes implemented
- [ ] `npm run lint` passes with no warnings
- [ ] `npm run build` succeeds
- [ ] Manual verification confirms no regressions
- [ ] All changes committed with descriptive messages
</verification>

<success_criteria>

- Comprehensive performance analysis documented
- High-impact performance issues fixed
- Build passes without errors
- No visual or functional regressions
- Changes committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/61-react-performance-review/61-01-SUMMARY.md` with:
- Analysis findings (categorized by type)
- Fixes implemented (with before/after where measurable)
- Any deferred items (issues found but not fixed, with rationale)
- Bundle size comparison if changed
</output>
