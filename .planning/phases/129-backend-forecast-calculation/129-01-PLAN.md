---
phase: 129-backend-forecast-calculation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-membership-fees.php
  - includes/class-rest-api.php
autonomous: true

must_haves:
  truths:
    - "API accepts forecast=true parameter and returns next season key (2026-2027)"
    - "Forecast response includes all current season members with 100% pro-rata fees"
    - "Forecast correctly applies family discounts based on current address groupings"
    - "Forecast response omits nikki_total and nikki_saldo fields"
  artifacts:
    - path: "includes/class-membership-fees.php"
      provides: "get_next_season_key() method"
      contains: "get_next_season_key"
    - path: "includes/class-rest-api.php"
      provides: "forecast parameter handling in get_fee_list()"
      contains: "forecast"
  key_links:
    - from: "includes/class-rest-api.php"
      to: "MembershipFees::get_next_season_key()"
      via: "method call in get_fee_list()"
      pattern: "get_next_season_key"
    - from: "includes/class-rest-api.php"
      to: "MembershipFees::calculate_fee_with_family_discount()"
      via: "forecast calculation path"
      pattern: "calculate_fee_with_family_discount"
---

<objective>
Add forecast calculation capability to the membership fees API endpoint.

Purpose: Enable the frontend (Phase 130) to request next season fee projections for budget planning. The forecast uses current membership data with 100% pro-rata and omits Nikki billing data.

Output: Modified `/stadion/v1/fees` endpoint that accepts `forecast=true` parameter and returns next season projections.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/129-backend-forecast-calculation/129-RESEARCH.md
@includes/class-membership-fees.php
@includes/class-rest-api.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_next_season_key() method to MembershipFees</name>
  <files>includes/class-membership-fees.php</files>
  <action>
Add a new public method `get_next_season_key()` to the `Stadion\Fees\MembershipFees` class.

Location: Add immediately after the existing `get_season_key()` method (around line 392).

Implementation:
```php
/**
 * Get the next season key (one year ahead of current/specified season)
 *
 * Takes a season key in "YYYY-YYYY" format and returns the next season.
 * Example: "2025-2026" returns "2026-2027"
 *
 * @param string|null $current_season Optional season key, defaults to current season.
 * @return string Next season key in "YYYY-YYYY" format.
 */
public function get_next_season_key( ?string $current_season = null ): string {
    if ( $current_season === null ) {
        $current_season = $this->get_season_key();
    }

    // Extract start year from "YYYY-YYYY" format
    $season_start_year = (int) substr( $current_season, 0, 4 );

    // Next season is +1 year
    $next_start_year = $season_start_year + 1;

    return $next_start_year . '-' . ( $next_start_year + 1 );
}
```

Key points:
- Use simple integer arithmetic on the year string (don't use DateTime)
- Follow existing coding style (same docblock format, same type hints)
- Method is stateless - can be called with explicit season or defaults to current
  </action>
  <verify>
Run `composer lint` to verify code style compliance. Verify method exists by searching for `get_next_season_key` in the file.
  </verify>
  <done>
MembershipFees class has `get_next_season_key()` method that returns "2026-2027" when current season is "2025-2026".
  </done>
</task>

<task type="auto">
  <name>Task 2: Add forecast parameter to /fees endpoint</name>
  <files>includes/class-rest-api.php</files>
  <action>
Modify the `/stadion/v1/fees` endpoint to support forecast mode. Two changes required:

**Change 1: Add `forecast` argument to route registration** (around line 662-669)

Add the forecast parameter to the args array:
```php
'args' => [
    'season' => [
        'default'           => null,
        'validate_callback' => function ( $param ) {
            return $param === null || preg_match( '/^\d{4}-\d{4}$/', $param );
        },
    ],
    'forecast' => [
        'default'           => false,
        'sanitize_callback' => 'rest_sanitize_boolean',
        'validate_callback' => 'rest_is_boolean',
        'description'       => 'Calculate forecast for next season with 100% pro-rata',
    ],
],
```

**Change 2: Modify `get_fee_list()` method** (starting at line 2633)

Replace the current implementation with forecast-aware logic:

```php
public function get_fee_list( $request ) {
    $forecast = $request->get_param( 'forecast' );
    $fees     = new \Stadion\Fees\MembershipFees();

    // Determine season
    if ( $forecast ) {
        // Forecast always uses next season (ignore season parameter)
        $season = $fees->get_next_season_key();
    } else {
        $season = $request->get_param( 'season' );
        if ( $season === null ) {
            $season = $fees->get_season_key();
        }
    }

    // Nikki year = first 4 chars of season (2025-2026 => 2025)
    $nikki_year = substr( $season, 0, 4 );

    // Query all person posts
    $query = new \WP_Query(
        [
            'post_type'      => 'person',
            'posts_per_page' => -1,
            'post_status'    => 'publish',
            'orderby'        => 'meta_value',
            'meta_key'       => 'first_name',
            'order'          => 'ASC',
            'no_found_rows'  => true,
        ]
    );

    $results = [];

    foreach ( $query->posts as $person ) {
        if ( $forecast ) {
            // Forecast: calculate fee with family discount, override pro-rata to 100%
            $fee_data = $fees->calculate_fee_with_family_discount( $person->ID, $season );

            // Skip non-calculable members
            if ( $fee_data === null ) {
                continue;
            }

            // Override pro-rata to 100% for forecast
            $fee_data['prorata_percentage']  = 1.0;
            $fee_data['final_fee']           = $fee_data['fee_after_discount'];
            $fee_data['registration_date']   = null;
            $fee_data['from_cache']          = false;
            $fee_data['calculated_at']       = current_time( 'Y-m-d H:i:s' );
        } else {
            // Normal: use cached calculation with lid-sinds pro-rata
            $fee_data = $fees->get_fee_for_person_cached( $person->ID, $season );

            // Skip non-calculable members
            if ( $fee_data === null ) {
                continue;
            }
        }

        // Get person name
        $first_name = get_field( 'first_name', $person->ID ) ?: '';
        $last_name  = get_field( 'last_name', $person->ID ) ?: '';

        $result = [
            'id'                     => $person->ID,
            'first_name'             => $first_name,
            'last_name'              => $last_name,
            'category'               => $fee_data['category'],
            'leeftijdsgroep'         => $fee_data['leeftijdsgroep'],
            'base_fee'               => $fee_data['base_fee'],
            'family_discount_rate'   => $fee_data['family_discount_rate'],
            'family_discount_amount' => $fee_data['family_discount_amount'],
            'fee_after_discount'     => $fee_data['fee_after_discount'],
            'prorata_percentage'     => $fee_data['prorata_percentage'],
            'final_fee'              => $fee_data['final_fee'],
            'family_key'             => $fee_data['family_key'],
            'family_size'            => $fee_data['family_size'],
            'family_position'        => $fee_data['family_position'],
            'lid_sinds'              => $fee_data['registration_date'] ?? null,
            'from_cache'             => $fee_data['from_cache'] ?? false,
            'calculated_at'          => $fee_data['calculated_at'] ?? null,
        ];

        // Only include Nikki data for current season (not forecast)
        if ( ! $forecast ) {
            $nikki_total            = get_post_meta( $person->ID, '_nikki_' . $nikki_year . '_total', true );
            $nikki_saldo            = get_post_meta( $person->ID, '_nikki_' . $nikki_year . '_saldo', true );
            $result['nikki_total']  = $nikki_total !== '' ? (float) $nikki_total : null;
            $result['nikki_saldo']  = $nikki_saldo !== '' ? (float) $nikki_saldo : null;
        }

        $results[] = $result;
    }

    // Sort by category priority, then name
    $category_order = [ 'mini' => 1, 'pupil' => 2, 'junior' => 3, 'senior' => 4, 'recreant' => 5, 'donateur' => 6 ];
    usort(
        $results,
        function ( $a, $b ) use ( $category_order ) {
            $cat_cmp = ( $category_order[ $a['category'] ] ?? 99 ) <=> ( $category_order[ $b['category'] ] ?? 99 );
            if ( $cat_cmp !== 0 ) {
                return $cat_cmp;
            }
            return strcasecmp( $a['first_name'] . ' ' . $a['last_name'], $b['first_name'] . ' ' . $b['last_name'] );
        }
    );

    return rest_ensure_response(
        [
            'season'   => $season,
            'forecast' => (bool) $forecast,
            'total'    => count( $results ),
            'members'  => $results,
        ]
    );
}
```

Key changes from existing code:
1. Added `$forecast` variable from request parameter
2. Season determination now has forecast branch (uses `get_next_season_key()`)
3. Added `'no_found_rows' => true` to WP_Query for performance
4. Forecast path uses `calculate_fee_with_family_discount()` directly with 100% pro-rata override
5. Nikki data conditionally excluded when `$forecast` is true
6. Response includes `'forecast' => (bool) $forecast` flag
7. Sort function now uses concatenated name (was using undefined `$a['name']`)
  </action>
  <verify>
1. Run `composer lint` to verify code style
2. Test API endpoint:
   - `curl "https://stadion.svawc.nl/wp-json/stadion/v1/fees"` - returns current season data with nikki fields
   - `curl "https://stadion.svawc.nl/wp-json/stadion/v1/fees?forecast=true"` - returns next season (2026-2027) with 100% pro-rata, no nikki fields
  </verify>
  <done>
- `/stadion/v1/fees?forecast=true` returns next season key (2026-2027)
- Forecast response has `prorata_percentage: 1.0` for all members
- Forecast response has no `nikki_total` or `nikki_saldo` fields
- Response includes `"forecast": true` flag
- Family discounts still applied correctly (same family_key, family_position, discount rates)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Lint check:** `composer lint` passes with 0 errors
2. **Method exists:** `grep -n "get_next_season_key" includes/class-membership-fees.php` shows the new method
3. **API test (current):** `curl -s "URL/wp-json/stadion/v1/fees" | jq '.season, .forecast, (.members[0] | keys)'` shows current season, forecast=false, includes nikki fields
4. **API test (forecast):** `curl -s "URL/wp-json/stadion/v1/fees?forecast=true" | jq '.season, .forecast, (.members[0] | keys)'` shows next season, forecast=true, no nikki fields
5. **Pro-rata check:** `curl -s "URL/wp-json/stadion/v1/fees?forecast=true" | jq '.members | map(.prorata_percentage) | unique'` shows only `[1]`
6. **Family discount check:** Verify members at same address still have family_position values 1, 2, 3+ and corresponding discount rates
</verification>

<success_criteria>
Phase 129 is complete when:

1. **FORE-01** - System calculates next season key: `get_next_season_key()` returns "2026-2027" for current season "2025-2026"
2. **FORE-02** - Forecast uses current members: Same person posts queried as normal endpoint
3. **FORE-03** - 100% pro-rata applied: All forecast members have `prorata_percentage: 1.0`
4. **FORE-04** - Family discounts maintained: Same `family_key` groupings as current season
5. **FORE-05** - Family positions recalculated: Same `family_position` and discount rates
6. **API-01** - Accepts forecast parameter: `?forecast=true` works
7. **API-02** - Next season key returned: Response `season` is "2026-2027"
8. **API-03** - Nikki fields omitted: Forecast response has no `nikki_total` or `nikki_saldo`

All 8 requirements for Phase 129 are satisfied.
</success_criteria>

<output>
After completion, create `.planning/phases/129-backend-forecast-calculation/129-01-SUMMARY.md`
</output>
