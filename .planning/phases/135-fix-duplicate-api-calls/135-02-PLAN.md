---
phase: 135-fix-duplicate-api-calls
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.jsx
  - src/App.jsx
  - src/router.jsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Dashboard page load shows single API call per endpoint in network panel"
    - "Page transitions make single API call per endpoint"
    - "React Router uses data router pattern (createBrowserRouter)"
  artifacts:
    - path: "src/router.jsx"
      provides: "Route configuration at module scope"
      contains: "createBrowserRouter"
    - path: "src/main.jsx"
      provides: "App entry point with RouterProvider"
      contains: "RouterProvider"
    - path: "src/App.jsx"
      provides: "Root layout component (no Routes JSX)"
      min_lines: 30
  key_links:
    - from: "src/main.jsx"
      to: "src/router.jsx"
      via: "import router"
      pattern: "import.*router.*from.*router"
    - from: "src/main.jsx"
      to: "RouterProvider"
      via: "router prop"
      pattern: "<RouterProvider.*router="
---

<objective>
Migrate from BrowserRouter to createBrowserRouter data router pattern to fix double-mount issue causing 2x API calls.

Purpose: The investigation confirmed entire React tree mounts twice ~1 second apart on page load (production, not StrictMode). All previous attempts (remove StrictMode, ApprovalCheck refactor, Routes flattening, QueryClient options) failed. The remaining hypothesis is that BrowserRouter's JSX-based routing may be causing navigation-triggered remounts. The modern createBrowserRouter pattern defines routes as data at module scope, which should prevent this.

Output: Router configuration at module scope, RouterProvider replacing BrowserRouter, single API calls per endpoint on page load.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/135-fix-duplicate-api-calls/135-01-SUMMARY.md
@.planning/phases/135-fix-duplicate-api-calls/135-VERIFICATION.md
@.planning/phases/135-fix-duplicate-api-calls/INVESTIGATION.md
@src/main.jsx
@src/App.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create router.jsx with route configuration at module scope</name>
  <files>src/router.jsx</files>
  <action>
Create a new file `src/router.jsx` that defines routes using `createBrowserRouter` at module scope.

Key requirements:
1. Import `createBrowserRouter` from `react-router-dom`
2. Define ALL routes as a route configuration object (not JSX)
3. Routes must be created at MODULE SCOPE (outside any function) - this is critical
4. Preserve the current route structure from App.jsx:
   - `/login` - public route with Login component
   - `/` - protected Dashboard
   - `/people`, `/people/:id`, `/people/:id/family-tree`
   - `/vog`, `/contributie`
   - `/tuchtzaken` - with FairplayRoute wrapper
   - `/teams`, `/teams/:id`
   - `/commissies`, `/commissies/:id`
   - `/dates`, `/todos`
   - `/feedback`, `/feedback/:id`
   - `/settings`, `/settings/:tab`, `/settings/:tab/:subtab`
   - Various settings sub-routes
   - Fallback `*` route

5. Use `lazy()` function from react-router-dom for code-splitting (replaces React.lazy)
6. Use `element` property for components, `children` for nested routes
7. Create a root layout route that applies ProtectedRoute and ApprovalCheck
8. Export the router as default

The route config pattern:
```javascript
import { createBrowserRouter } from 'react-router-dom';

// Routes defined at MODULE SCOPE - critical for preventing remounts
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    children: [
      { index: true, element: <Dashboard /> },
      { path: 'people', element: <PeopleList /> },
      // ... etc
    ]
  }
]);

export default router;
```

Move the following from App.jsx to router.jsx:
- All lazy() imports for page components
- PageLoader component
- ProtectedRoute component (or move to separate file)
- ApprovalCheck component (or keep in App.jsx if used elsewhere)
- FairplayRoute component
- ProtectedLayout component (can be adapted to work with createBrowserRouter)

DO NOT include:
- QueryClientProvider (stays in main.jsx)
- UpdateBanner, OfflineBanner, InstallPrompt, IOSInstallModal (these global components stay in App.jsx which becomes the root layout)
  </action>
  <verify>
- `cat src/router.jsx` shows createBrowserRouter at module scope
- No Routes/Route JSX, only route configuration objects
- `npm run lint` passes
  </verify>
  <done>Router configuration exists at module scope using createBrowserRouter pattern</done>
</task>

<task type="auto">
  <name>Task 2: Update main.jsx to use RouterProvider</name>
  <files>src/main.jsx</files>
  <action>
Update main.jsx to use RouterProvider instead of BrowserRouter:

1. Remove `BrowserRouter` import from react-router-dom
2. Add `RouterProvider` import from react-router-dom
3. Import router from `./router.jsx`
4. Replace `<BrowserRouter><App /></BrowserRouter>` with `<RouterProvider router={router} />`
5. Keep QueryClientProvider wrapping RouterProvider
6. Keep the onlineManager setup unchanged

Before:
```javascript
import { BrowserRouter } from 'react-router-dom';
import App from './App';
// ...
<QueryClientProvider client={queryClient}>
  <BrowserRouter>
    <App />
  </BrowserRouter>
</QueryClientProvider>
```

After:
```javascript
import { RouterProvider } from 'react-router-dom';
import router from './router';
// ...
<QueryClientProvider client={queryClient}>
  <RouterProvider router={router} />
</QueryClientProvider>
```

The key change is that the router is now created at module scope in router.jsx, not as JSX inside the render call. This prevents the router from being recreated on renders.
  </action>
  <verify>
- `cat src/main.jsx` shows RouterProvider with router prop
- No BrowserRouter import
- `npm run lint` passes
  </verify>
  <done>main.jsx uses RouterProvider with module-scoped router</done>
</task>

<task type="auto">
  <name>Task 3: Simplify App.jsx to root layout component</name>
  <files>src/App.jsx</files>
  <action>
Transform App.jsx from a routing component to a root layout component:

1. Remove all `Routes` and `Route` imports and JSX
2. Remove all lazy() imports (moved to router.jsx)
3. Remove PageLoader (moved to router.jsx)
4. Remove ProtectedRoute, ApprovalCheck, FairplayRoute, ProtectedLayout (moved to router.jsx or separate files)
5. Keep the global components that should appear on every page:
   - UpdateBanner
   - OfflineBanner
   - InstallPrompt
   - IOSInstallModal
6. Add `<Outlet />` from react-router-dom where child routes should render
7. Keep useTheme() hook call

The new App.jsx should look like:
```javascript
import { Outlet } from 'react-router-dom';
import { useTheme } from '@/hooks/useTheme';
import { useVersionCheck } from '@/hooks/useVersionCheck';
import { OfflineBanner } from '@/components/OfflineBanner';
import { InstallPrompt } from '@/components/InstallPrompt';
import { IOSInstallModal } from '@/components/IOSInstallModal';
import { RefreshCw } from 'lucide-react';

function UpdateBanner() {
  // ... keep existing implementation
}

function App() {
  useTheme();

  return (
    <div className="app-root">
      <UpdateBanner />
      <OfflineBanner />
      <InstallPrompt />
      <IOSInstallModal />
      <Outlet />
    </div>
  );
}

export default App;
```

Note: The ProtectedRoute/ApprovalCheck/Layout wrapping now happens in the route configuration in router.jsx, not here.
  </action>
  <verify>
- `cat src/App.jsx` shows Outlet, no Routes/Route
- No lazy() imports in App.jsx
- `npm run lint` passes
  </verify>
  <done>App.jsx is a clean root layout component with Outlet for child routes</done>
</task>

<task type="auto">
  <name>Task 4: Build, deploy, and verify single API calls</name>
  <files>dist/</files>
  <action>
Build the application and deploy to production:

1. Run `npm run build` to create production build
2. Verify build succeeds without errors
3. Run `bin/deploy.sh` to deploy to production
4. Document the deployment for verification

After deployment, the user should verify in production:
- Open DevTools Network panel
- Navigate to Dashboard
- Check that each endpoint is called exactly ONCE (not 2x)
- Key endpoints to watch:
  - /stadion/v1/dashboard
  - /wp/v2/users/me
  - /stadion/v1/todos
  - /stadion/v1/settings

If the double-mount issue is resolved, each endpoint should appear only once in the network panel on initial page load.
  </action>
  <verify>
- `npm run build` completes without errors
- `bin/deploy.sh` completes successfully
- dist/ folder contains updated manifest.json
  </verify>
  <done>Production deployed with createBrowserRouter pattern</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Code Structure Check:**
   - `src/router.jsx` exists with createBrowserRouter at module scope
   - `src/main.jsx` uses RouterProvider with imported router
   - `src/App.jsx` has no Routes/Route, uses Outlet

2. **Build Check:**
   - `npm run build` succeeds
   - `npm run lint` passes

3. **Production Check (requires human verification):**
   - Dashboard page load shows SINGLE request per endpoint
   - Navigate to People -> Dashboard -> Teams - single calls per endpoint
   - No duplicate request IDs in network panel
</verification>

<success_criteria>
- Router configuration lives at module scope in router.jsx
- BrowserRouter replaced with RouterProvider pattern
- Production build deploys successfully
- Ready for human verification of API call deduplication
</success_criteria>

<output>
After completion, create `.planning/phases/135-fix-duplicate-api-calls/135-02-SUMMARY.md`
</output>
