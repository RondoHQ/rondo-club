---
phase: 80-import-from-google
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-google-contacts-api-import.php
  - functions.php
autonomous: true

must_haves:
  truths:
    - "Google Contacts API can be queried for user's contacts"
    - "Contact data is correctly mapped to Stadion person fields"
    - "Contacts without email are skipped"
    - "Existing contacts are matched by email and only gaps are filled"
    - "Photos are sideloaded to WordPress media library"
    - "Birthdays create important_date posts"
    - "Teams create/link team posts with work_history"
  artifacts:
    - path: "includes/class-google-contacts-api-import.php"
      provides: "GoogleContactsAPIImport class with full import logic"
      min_lines: 300
  key_links:
    - from: "includes/class-google-contacts-api-import.php"
      to: "GoogleContactsConnection::get_decrypted_credentials"
      via: "OAuth token retrieval"
      pattern: "get_decrypted_credentials"
    - from: "includes/class-google-contacts-api-import.php"
      to: "Google\\Service\\PeopleService"
      via: "Google API client"
      pattern: "new.*PeopleService"
---

<objective>
Create the core Google Contacts API import class that pulls contacts from Google and imports them into Stadion.

Purpose: Implement all backend logic for fetching, mapping, and importing Google Contacts data with proper duplicate handling, photo sideloading, and birthday/team creation.

Output: `includes/class-google-contacts-api-import.php` with complete import functionality
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/80-import-from-google/80-CONTEXT.md
@.planning/phases/80-import-from-google/80-RESEARCH.md
@includes/class-google-contacts-connection.php
@includes/class-google-contacts-import.php (CSV import patterns to follow)
@includes/class-google-oauth.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GoogleContactsAPIImport class with core structure</name>
  <files>includes/class-google-contacts-api-import.php</files>
  <action>
Create `includes/class-google-contacts-api-import.php` in namespace `Stadion\Import` with:

**Class structure:**
```php
namespace Stadion\Import;

use Stadion\Calendar\GoogleOAuth;
use Stadion\Contacts\GoogleContactsConnection;
use Google\Service\PeopleService;

class GoogleContactsAPI {
    private int $user_id;
    private array $stats = [
        'contacts_imported' => 0,
        'contacts_updated' => 0,
        'contacts_skipped' => 0,
        'contacts_no_email' => 0,
        'teams_created' => 0,
        'dates_created' => 0,
        'photos_imported' => 0,
        'errors' => [],
    ];
    private array $team_map = []; // name => ID cache
    private ?PeopleService $service = null;

    public function __construct(int $user_id) { ... }
    public function import_all(): array { ... }
    private function get_people_service(): PeopleService { ... }
    private function fetch_contacts(?string $page_token = null): object { ... }
    private function process_contact(object $person): void { ... }
    private function should_skip_contact(object $person): bool { ... }
    private function get_primary_email(object $person): ?string { ... }
    private function find_by_email(string $email): ?int { ... }
    // Field import methods (fill gaps only)
    private function import_names(int $post_id, object $person): void { ... }
    private function import_contact_info(int $post_id, object $person): void { ... }
    private function import_addresses(int $post_id, object $person): void { ... }
    private function import_work_history(int $post_id, object $person): void { ... }
    private function import_birthday(int $post_id, object $person, string $full_name): void { ... }
    private function import_photo(int $post_id, object $person, string $full_name): void { ... }
    // Helpers
    private function get_or_create_team(string $name): int { ... }
    private function store_google_ids(int $post_id, string $resource_name, string $etag): void { ... }
    private function sideload_image(string $url, int $post_id, string $description): ?int { ... }
    private function get_user_accessible_person_ids(): array { ... }
}
```

**Key implementation details:**

1. **Constructor:** Store user_id, set time limit (600), raise memory limit

2. **get_people_service():**
   - Get credentials from `GoogleContactsConnection::get_decrypted_credentials($this->user_id)`
   - Create Google\Client with `GoogleOAuth::get_contacts_client(false, false)`
   - Set access token from credentials
   - Handle token refresh if expired (save refreshed tokens via `GoogleContactsConnection::update_credentials`)
   - Return new PeopleService($client)

3. **fetch_contacts($page_token):**
   - Call `$service->people_connections->listPeopleConnections('people/me', [...])`
   - personFields: 'names,emailAddresses,phoneNumbers,addresses,teams,birthdays,photos,urls,metadata'
   - pageSize: 100
   - pageToken: $page_token

4. **import_all():**
   ```php
   $pageToken = null;
   do {
       $response = $this->fetch_contacts($pageToken);
       $connections = $response->getConnections() ?: [];
       foreach ($connections as $person) {
           $this->process_contact($person);
       }
       $pageToken = $response->getNextPageToken();
   } while ($pageToken);

   // Update connection stats
   GoogleContactsConnection::update_connection($this->user_id, [
       'last_sync' => current_time('c'),
       'contact_count' => $this->stats['contacts_imported'] + $this->stats['contacts_updated'],
       'last_error' => null,
   ]);

   // Clear pending import flag
   GoogleContactsConnection::set_pending_import($this->user_id, false);

   return $this->stats;
   ```

5. **should_skip_contact($person):** Return true if no emailAddresses

6. **get_primary_email($person):**
   - Find email with metadata.primary = true, else first email
   - Return lowercase value

7. **find_by_email($email):**
   - Use direct database query (like CSV import pattern)
   - Search contact_info repeater for matching email type+value
   - Only search within user's accessible posts
   - Return post ID or null

8. **process_contact($person):**
   ```php
   if ($this->should_skip_contact($person)) {
       $this->stats['contacts_no_email']++;
       return;
   }

   $email = $this->get_primary_email($person);
   $existing_id = $this->find_by_email($email);

   if ($existing_id) {
       // Link and fill gaps
       $post_id = $existing_id;
       $this->stats['contacts_updated']++;
   } else {
       // Create new person
       $names = $person->getNames() ?: [];
       $name = $names[0] ?? null;
       $first_name = $name ? $name->getGivenName() : '';
       $last_name = $name ? $name->getFamilyName() : '';

       $post_id = wp_insert_post([
           'post_type' => 'person',
           'post_status' => 'publish',
           'post_title' => trim($first_name . ' ' . $last_name),
           'post_author' => $this->user_id,
       ]);

       if (is_wp_error($post_id)) {
           $this->stats['errors'][] = 'Failed to create: ' . ($name ? $name->getDisplayName() : 'Unknown');
           return;
       }
       $this->stats['contacts_imported']++;
   }

   // Store Google IDs
   $this->store_google_ids($post_id, $person->getResourceName(), $person->getEtag());

   // Import fields (fill gaps only)
   $this->import_names($post_id, $person);
   $this->import_contact_info($post_id, $person);
   $this->import_addresses($post_id, $person);
   $this->import_work_history($post_id, $person);

   $full_name = get_the_title($post_id);
   $this->import_birthday($post_id, $person, $full_name);
   $this->import_photo($post_id, $person, $full_name);
   ```

9. **store_google_ids($post_id, $resource_name, $etag):**
   ```php
   update_post_meta($post_id, '_google_contact_id', $resource_name);
   update_post_meta($post_id, '_google_etag', $etag);
   update_post_meta($post_id, '_google_last_import', current_time('c'));
   ```
  </action>
  <verify>File exists and has proper namespace/class structure: `grep -n "class GoogleContactsAPI" includes/class-google-contacts-api-import.php`</verify>
  <done>GoogleContactsAPIImport class created with core structure, Google API integration, and main import loop</done>
</task>

<task type="auto">
  <name>Task 2: Implement field mapping methods (fill gaps only)</name>
  <files>includes/class-google-contacts-api-import.php</files>
  <action>
Implement all field import methods in the GoogleContactsAPI class. Each method must follow the "fill gaps only" pattern - only write to empty fields.

**import_names($post_id, $person):**
```php
$names = $person->getNames() ?: [];
$name = $names[0] ?? null;
if (!$name) return;

$existing_first = get_field('first_name', $post_id);
$existing_last = get_field('last_name', $post_id);

if (empty($existing_first) && $name->getGivenName()) {
    update_field('first_name', $name->getGivenName(), $post_id);
}
if (empty($existing_last) && $name->getFamilyName()) {
    update_field('last_name', $name->getFamilyName(), $post_id);
}
```

**import_contact_info($post_id, $person):**
- Get existing contact_info via get_field()
- For each email in person->getEmailAddresses(): add if not already present
- For each phone in person->getPhoneNumbers(): add if not already present
  - Map phone type: mobile/workMobile -> 'mobile', all others -> 'phone'
  - Use canonicalForm if available, else value
- For each url in person->getUrls(): add if not already present
  - Detect type: linkedin/twitter/facebook/instagram/website
- If any items added, update_field('contact_info', $combined, $post_id)

**import_addresses($post_id, $person):**
- Get existing addresses via get_field()
- For each address in person->getAddresses():
  - Map: streetAddress+extendedAddress -> street, city, region -> state, postalCode, country, type -> address_label
  - Skip if street is already present in existing addresses
- If any items added, update_field('addresses', $combined, $post_id)

**import_work_history($post_id, $person):**
- Get existing work_history via get_field()
- For each org in person->getTeams():
  - Get or create team by name
  - Build work_history entry: team ID, title, is_current, start_date, end_date
  - Skip if team ID already in existing work history
- If any items added, update_field('work_history', $combined, $post_id)

**import_birthday($post_id, $person, $full_name):**
- Get birthdays from person->getBirthdays(), use first
- If no birthday, return
- Check if birthday already exists (same pattern as CSV import)
- If exists, return
- Parse date: year (may be 0), month, day -> format as Y-m-d or 0000-m-d
- Create important_date post with is_recurring=true, related_people=[$post_id]
- Set date_type taxonomy to 'birthday'
- Increment stats['dates_created']

**import_photo($post_id, $person, $full_name):**
- If person already has featured image (has_post_thumbnail), return
- Get photos from person->getPhotos()
- Find primary photo (metadata.primary=true) or use first
- Skip if photo has default=true (placeholder)
- Get URL, append ?sz=400 for better quality
- Call sideload_image()
- If successful, set_post_thumbnail($post_id, $attachment_id)
- Increment stats['photos_imported']

**sideload_image($url, $post_id, $description):**
```php
require_once ABSPATH . 'wp-admin/includes/file.php';
require_once ABSPATH . 'wp-admin/includes/media.php';
require_once ABSPATH . 'wp-admin/includes/image.php';

$tmp = download_url($url);
if (is_wp_error($tmp)) {
    return null;
}

$filename = sanitize_title(strtolower($description)) . '.jpg';
$file_array = ['name' => $filename, 'tmp_name' => $tmp];

$attachment_id = media_handle_sideload($file_array, $post_id, $description);

if (is_wp_error($attachment_id)) {
    @unlink($tmp);
    return null;
}

return $attachment_id;
```

**get_or_create_team($name):**
Follow exact pattern from CSV import class - check team_map cache, then get_page_by_title, then wp_insert_post if needed.

**Helper: detect_url_type($url):**
```php
$url_lower = strtolower($url);
if (strpos($url_lower, 'linkedin.com') !== false) return 'linkedin';
if (strpos($url_lower, 'twitter.com') !== false || strpos($url_lower, 'x.com') !== false) return 'twitter';
if (strpos($url_lower, 'facebook.com') !== false) return 'facebook';
if (strpos($url_lower, 'instagram.com') !== false) return 'instagram';
return 'website';
```

**Helper: map_phone_type($google_type):**
```php
$mobile_types = ['mobile', 'workMobile'];
return in_array(strtolower($google_type ?? ''), $mobile_types) ? 'mobile' : 'phone';
```
  </action>
  <verify>`grep -c "function import_" includes/class-google-contacts-api-import.php` shows 6 import methods</verify>
  <done>All field mapping methods implemented with fill-gaps-only pattern, proper type mapping for phones/URLs, and team creation</done>
</task>

<task type="auto">
  <name>Task 3: Register class and add unit test scaffolding</name>
  <files>includes/class-google-contacts-api-import.php, functions.php</files>
  <action>
1. **Add class loading to functions.php:**
   In the stadion_init() function, add the require for the new class after the existing imports:
   ```php
   require_once get_template_directory() . '/includes/class-google-contacts-api-import.php';
   ```

   Place it near the other import classes (class-google-contacts-import.php, class-monica-import.php, class-vcard-import.php).

2. **Add get_user_accessible_person_ids() helper to the import class:**
   ```php
   private function get_user_accessible_person_ids(): array {
       global $wpdb;

       // Admins get all
       if (user_can($this->user_id, 'manage_options')) {
           return $wpdb->get_col(
               "SELECT ID FROM {$wpdb->posts}
                WHERE post_type = 'person'
                AND post_status = 'publish'"
           );
       }

       // Regular users get only their own
       return $wpdb->get_col(
           $wpdb->prepare(
               "SELECT ID FROM {$wpdb->posts}
                WHERE post_type = 'person'
                AND post_status = 'publish'
                AND post_author = %d",
               $this->user_id
           )
       );
   }
   ```

3. **Add find_by_email implementation:**
   ```php
   private function find_by_email(string $email): ?int {
       global $wpdb;

       $accessible_ids = $this->get_user_accessible_person_ids();
       if (empty($accessible_ids)) {
           return null;
       }

       $id_list = implode(',', array_map('intval', $accessible_ids));

       // ACF stores repeater data as: contact_info_0_contact_type, contact_info_0_contact_value
       $result = $wpdb->get_var(
           $wpdb->prepare(
               "SELECT p.ID FROM {$wpdb->posts} p
                INNER JOIN {$wpdb->postmeta} pm_type ON p.ID = pm_type.post_id
                INNER JOIN {$wpdb->postmeta} pm_value ON p.ID = pm_value.post_id
                WHERE p.post_type = 'person'
                AND p.post_status = 'publish'
                AND p.ID IN ({$id_list})
                AND pm_type.meta_key LIKE 'contact_info_%%_contact_type'
                AND pm_type.meta_value = 'email'
                AND pm_value.meta_key = REPLACE(pm_type.meta_key, '_contact_type', '_contact_value')
                AND LOWER(pm_value.meta_value) = LOWER(%s)
                LIMIT 1",
               $email
           )
       );

       return $result ? (int) $result : null;
   }
   ```

4. **Ensure proper error handling in get_people_service():**
   ```php
   private function get_people_service(): PeopleService {
       if ($this->service) {
           return $this->service;
       }

       $credentials = GoogleContactsConnection::get_decrypted_credentials($this->user_id);
       if (!$credentials) {
           throw new \Exception('No Google Contacts credentials found');
       }

       $client = GoogleOAuth::get_contacts_client(false, false);
       $client->setAccessToken($credentials);

       // Refresh token if expired
       if ($client->isAccessTokenExpired()) {
           $refresh_token = $client->getRefreshToken();
           if (!$refresh_token) {
               throw new \Exception('Access token expired and no refresh token available');
           }
           $client->fetchAccessTokenWithRefreshToken($refresh_token);
           GoogleContactsConnection::update_credentials($this->user_id, $client->getAccessToken());
       }

       $this->service = new PeopleService($client);
       return $this->service;
   }
   ```
  </action>
  <verify>`grep -n "class-google-contacts-api-import.php" functions.php` shows require line; `php -l includes/class-google-contacts-api-import.php` shows no syntax errors</verify>
  <done>Class registered in functions.php and all helper methods implemented with proper access control and error handling</done>
</task>

</tasks>

<verification>
1. Syntax check: `php -l includes/class-google-contacts-api-import.php`
2. Class is loadable: `grep "class-google-contacts-api-import" functions.php`
3. Key methods exist: `grep -c "private function" includes/class-google-contacts-api-import.php` shows 15+ methods
4. Uses GoogleContactsConnection: `grep "GoogleContactsConnection" includes/class-google-contacts-api-import.php`
5. Uses PeopleService: `grep "PeopleService" includes/class-google-contacts-api-import.php`
</verification>

<success_criteria>
- GoogleContactsAPIImport class exists with all required methods
- Class is loaded via functions.php
- Follows fill-gaps-only pattern for all field imports
- Proper token refresh handling
- Photo sideloading implemented
- Birthday and team creation implemented
- Access control respects user boundaries
</success_criteria>

<output>
After completion, create `.planning/phases/80-import-from-google/80-01-SUMMARY.md`
</output>
