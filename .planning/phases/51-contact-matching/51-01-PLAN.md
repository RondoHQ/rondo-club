---
phase: 51-contact-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-calendar-matcher.php
  - includes/class-rest-calendar.php
  - includes/class-google-calendar-provider.php
  - includes/class-caldav-provider.php
  - functions.php
autonomous: true
---

<objective>
Implement contact matching algorithm that links calendar event attendees to CRM contacts.

Purpose: Enable the system to show meetings with known contacts on their profile pages, and prepare for auto-logging past meetings as activities.

Output: PRM_Calendar_Matcher class with email-first matching, fuzzy name fallback, and transient-based email lookup cache.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Calendar implementation reference
@Calendar-Integration-Implementation-Plan.md (section 2 - Contact Matching Logic)

# Prior calendar work
@.planning/phases/49-google-calendar-provider/49-01-SUMMARY.md
@.planning/phases/50-caldav-provider/50-01-SUMMARY.md

# Existing source files
@includes/class-google-calendar-provider.php
@includes/class-caldav-provider.php
@includes/class-rest-calendar.php
@acf-json/group_person_fields.json (contact_info repeater with email contact_type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PRM_Calendar_Matcher class</name>
  <files>includes/class-calendar-matcher.php, functions.php</files>
  <action>
Create new class `includes/class-calendar-matcher.php` with contact matching logic.

**Class structure:**
```php
class PRM_Calendar_Matcher {
    /**
     * Match attendees from a calendar event to CRM people
     *
     * @param int   $user_id   WordPress user ID (owner of contacts)
     * @param array $attendees Array of [{email, name, status}]
     * @return array Array of [{person_id, match_type, confidence, attendee_email}]
     */
    public static function match_attendees(int $user_id, array $attendees): array;

    /**
     * Build email->person_id lookup cache for a user
     * Uses transient with 24-hour expiration
     *
     * @param int  $user_id WordPress user ID
     * @param bool $force   Force rebuild even if cache exists
     * @return array Email->person_id lookup map
     */
    public static function get_email_lookup(int $user_id, bool $force = false): array;

    /**
     * Invalidate email lookup cache (call on contact save)
     */
    public static function invalidate_cache(int $user_id): void;

    /**
     * Match single attendee - try email then fuzzy name
     *
     * @param int   $user_id  WordPress user ID
     * @param array $attendee Single attendee {email, name}
     * @param array $lookup   Email->person_id lookup map
     * @return array|null Match data or null if no match
     */
    private static function match_single(int $user_id, array $attendee, array $lookup): ?array;

    /**
     * Try fuzzy name match when email fails
     *
     * @param int    $user_id WordPress user ID
     * @param string $name    Attendee display name
     * @return array|null Match with person_id, match_type, confidence
     */
    private static function fuzzy_name_match(int $user_id, string $name): ?array;
}
```

**Match types and confidence scores:**
- `email_exact`: Exact email match (lowercase comparison) → 100%
- `name_exact`: Full name exact match (first + last) → 80%
- `name_partial`: First name only match (if unique in user's contacts) → 60%
- `name_fuzzy`: Levenshtein distance ≤ 2 → 50%

**Email lookup cache:**
- Transient key: `prm_email_lookup_{$user_id}`
- Expiration: DAY_IN_SECONDS (24 hours)
- Build by querying all user's people, extracting emails from `contact_info` ACF repeater
- Normalize emails: strtolower() + trim()

**Fuzzy name matching algorithm:**
1. Parse attendee name into first/last (split on space, handle "Last, First" format)
2. Query user's people with first_name + last_name meta comparison
3. Exact full name match → 80% confidence
4. If no exact match and first name is unique → 60% confidence
5. Levenshtein ≤ 2 on full name → 50% confidence
6. Return null if no match

**Performance notes:**
- Email lookup is O(1) via transient cache
- Name matching queries database - limit to when email fails
- For name uniqueness check, count matches first before returning

Add to functions.php autoloader class_map:
```php
'PRM_Calendar_Matcher' => 'class-calendar-matcher.php',
```

Add ACF save hook to invalidate cache when person is saved:
```php
add_action('acf/save_post', function($post_id) {
    if (get_post_type($post_id) === 'person') {
        $user_id = get_post_field('post_author', $post_id);
        PRM_Calendar_Matcher::invalidate_cache($user_id);
    }
}, 20);
```
  </action>
  <verify>
    - File exists: includes/class-calendar-matcher.php
    - Class autoloads: `php -l includes/class-calendar-matcher.php` shows no syntax errors
    - functions.php has class in autoloader map
    - ACF save hook registered for cache invalidation
  </verify>
  <done>
    - PRM_Calendar_Matcher class with match_attendees(), get_email_lookup(), fuzzy_name_match() methods
    - Transient-based email cache with 24h expiration
    - Cache invalidation on person save via ACF hook
    - Match types: email_exact (100%), name_exact (80%), name_partial (60%), name_fuzzy (50%)
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate matching into calendar providers</name>
  <files>includes/class-google-calendar-provider.php, includes/class-caldav-provider.php</files>
  <action>
Update both calendar providers to call PRM_Calendar_Matcher after upserting events.

**In PRM_Google_Calendar_Provider::upsert_event():**
After the existing meta updates (around line 201), add:

```php
// Run contact matching
$matches = PRM_Calendar_Matcher::match_attendees($user_id, $attendees);
update_post_meta($post_id, '_matched_people', wp_json_encode($matches));
```

**In PRM_CalDAV_Provider::upsert_event():**
Same pattern - after storing `_attendees` meta, add matching call.

**Important:** The `_matched_people` meta already exists in the CPT design. Store as JSON array:
```json
[
  {"person_id": 123, "match_type": "email_exact", "confidence": 100, "attendee_email": "john@example.com"},
  {"person_id": 456, "match_type": "name_partial", "confidence": 60, "attendee_email": null}
]
```

This enables querying events by person:
```php
// Find events with a specific person
$events = get_posts([
    'post_type' => 'calendar_event',
    'meta_query' => [
        ['key' => '_matched_people', 'value' => '"person_id":123', 'compare' => 'LIKE'],
    ],
]);
```
  </action>
  <verify>
    - PRM_Google_Calendar_Provider::upsert_event() calls PRM_Calendar_Matcher::match_attendees()
    - PRM_CalDAV_Provider::upsert_event() calls PRM_Calendar_Matcher::match_attendees()
    - Both store results in _matched_people post meta as JSON
  </verify>
  <done>
    - Google Calendar provider stores _matched_people on sync
    - CalDAV provider stores _matched_people on sync
    - Events can be queried by matched person_id using LIKE on JSON
  </done>
</task>

<task type="auto">
  <name>Task 3: Add meetings-by-person REST endpoint</name>
  <files>includes/class-rest-calendar.php</files>
  <action>
Add new REST endpoint to get meetings for a specific person.

**Endpoint:** `GET /prm/v1/people/{id}/meetings`

**Parameters:**
- `upcoming` (bool): Only future events (default: true)
- `past` (bool): Only past events (default: false)
- `limit` (int): Max results per category (default: 10)

**Response format:**
```json
{
  "upcoming": [
    {
      "id": 456,
      "title": "Weekly Sync",
      "start_time": "2026-01-20T14:00:00",
      "end_time": "2026-01-20T15:00:00",
      "location": "Google Meet",
      "meeting_url": "https://meet.google.com/abc-xyz",
      "all_day": false,
      "match_type": "email_exact",
      "confidence": 100,
      "matched_attendee_email": "john@example.com",
      "other_attendees": ["jane@company.com", "bob@company.com"],
      "calendar_name": "Work Calendar",
      "connection_id": "conn_abc123"
    }
  ],
  "past": [],
  "total_upcoming": 3,
  "total_past": 12
}
```

**Implementation:**

Register route in `register_routes()`:
```php
register_rest_route('prm/v1', '/people/(?P<id>\d+)/meetings', [
    'methods'             => WP_REST_Server::READABLE,
    'callback'            => [$this, 'get_person_meetings'],
    'permission_callback' => [$this, 'check_person_access'],
    'args'                => [
        'id' => ['validate_callback' => 'is_numeric'],
        'upcoming' => ['default' => true, 'type' => 'boolean'],
        'past' => ['default' => false, 'type' => 'boolean'],
        'limit' => ['default' => 10, 'type' => 'integer'],
    ],
]);
```

**Query logic:**
1. Verify person belongs to current user (or user has access)
2. Query calendar_event posts where `_matched_people` LIKE contains person_id
3. Filter by date range based on `upcoming` and `past` params
4. Order by _start_time
5. Format response with event details and match info

**Helper method `check_person_access`** (may already exist in class):
```php
public function check_person_access($request) {
    $person_id = $request['id'] ?? $request['person_id'] ?? 0;
    $person = get_post($person_id);
    if (!$person || $person->post_type !== 'person') {
        return false;
    }
    // Check if user owns person or has access via workspace/sharing
    return PRM_Access_Control::can_access($person_id);
}
```
  </action>
  <verify>
    - REST endpoint registered: /prm/v1/people/{id}/meetings
    - GET request with person_id returns meetings in correct format
    - `upcoming=true` returns only future events
    - `past=true` returns only past events
    - Permission check verifies user can access the person
  </verify>
  <done>
    - GET /prm/v1/people/{id}/meetings endpoint returns person's calendar events
    - Response includes upcoming and past arrays with event details
    - Match type, confidence, and matched email included in response
    - Other attendees listed for context
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `php -l includes/class-calendar-matcher.php` - no syntax errors
- [ ] PRM_Calendar_Matcher class has match_attendees(), get_email_lookup(), fuzzy_name_match()
- [ ] Google provider calls matching on sync
- [ ] CalDAV provider calls matching on sync
- [ ] REST endpoint `/prm/v1/people/{id}/meetings` returns correct response format
- [ ] `npm run build` succeeds (no frontend changes, but verify nothing broken)
</verification>

<success_criteria>
- PRM_Calendar_Matcher class implemented with email-first, fuzzy-name-fallback algorithm
- Transient cache for email lookups with 24h expiration
- Cache invalidation on person save
- Both calendar providers store _matched_people on sync
- REST endpoint returns meetings for a person with match details
- All existing functionality continues working
</success_criteria>

<output>
After completion, create `.planning/phases/51-contact-matching/51-01-SUMMARY.md`
</output>
