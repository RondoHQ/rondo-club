---
phase: 19-important-date-polish
plan: 02
type: execute
depends_on: []
files_modified: [includes/class-auto-title.php, includes/class-cli.php, src/components/ImportantDateModal.jsx]
---

<objective>
Update auto-generated Important Date titles to use full names instead of first names only, and create WP-CLI command to regenerate existing titles.

Purpose: Improve date title clarity when multiple people share the same first name.
Output: Full name titles ("Jan Ippen's Birthday" instead of "Jan's Birthday") with CLI migration tool.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@includes/class-auto-title.php
@src/components/ImportantDateModal.jsx

**Pattern reference:**
- Backend PHP auto-title in class-auto-title.php uses get_the_title() which returns full name
- Frontend JS in ImportantDateModal.jsx extracts first_name only for preview title
- Both need to use full name for consistency
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update frontend title auto-generation to use full name</name>
  <files>src/components/ImportantDateModal.jsx</files>
  <action>
In ImportantDateModal.jsx around lines 150-156, the title auto-generation extracts only first_name:

```javascript
const firstNames = watchedPeople.map(pId => {
  const person = allPeople.find(p => p.id === pId);
  if (person) {
    return decodeHtml(person.acf?.first_name || person.first_name || person.title?.rendered?.split(' ')[0] || '');
  }
  return null;
}).filter(Boolean);
```

Change to use full name:

```javascript
const fullNames = watchedPeople.map(pId => {
  const person = allPeople.find(p => p.id === pId);
  if (person) {
    // Use full name from title (which is auto-generated as "First Last")
    // Fall back to constructing from first_name + last_name if title not available
    const firstName = decodeHtml(person.acf?.first_name || person.first_name || '');
    const lastName = decodeHtml(person.acf?.last_name || person.last_name || '');
    const fullName = `${firstName} ${lastName}`.trim();

    // Use title.rendered as fallback (already contains full name)
    return fullName || decodeHtml(person.title?.rendered || '');
  }
  return null;
}).filter(Boolean);
```

Then update the title generation (around lines 158-168) to use fullNames instead of firstNames:

```javascript
if (fullNames.length > 0 && typeName) {
  let title;
  if (typeSlug === 'wedding') {
    title = fullNames.length >= 2
      ? `Wedding of ${fullNames[0]} & ${fullNames[1]}`
      : `Wedding of ${fullNames[0]}`;
  } else {
    title = `${fullNames[0]}'s ${typeName}`;
  }
  setValue('title', title);
}
```

Also update the autoGeneratedPatterns check (line 139-143) to handle both old and new format detection.
  </action>
  <verify>
1. Open PersonDetail for a person with first and last name
2. Click "Add date"
3. Select a date type (e.g., Birthday)
4. Auto-generated title should show "FirstName LastName's Birthday"
5. Test with Wedding type - should show "FirstName1 LastName1 & FirstName2 LastName2"
  </verify>
  <done>Frontend auto-generates titles with full names (e.g., "Jan Ippen's Birthday")</done>
</task>

<task type="auto">
  <name>Task 2: Verify backend auto-title uses full name (already correct)</name>
  <files>includes/class-auto-title.php</files>
  <action>
Review class-auto-title.php to confirm it already uses full names:

Line 111: `$full_name = html_entity_decode(get_the_title($person_id), ENT_QUOTES, 'UTF-8');`

The backend already uses `get_the_title()` which returns the full name (since Person post titles are auto-generated as "First Last").

No changes needed to class-auto-title.php - it already generates correct titles like "Jan Ippen's Birthday".

Document this finding: The backend was already correct. The issue was only in the frontend preview/auto-generation.
  </action>
  <verify>
1. Create a new important date via the UI (after Task 1)
2. Check the post title in WordPress admin or via REST API
3. Confirm backend-generated title matches frontend preview (both use full name)
  </verify>
  <done>Backend auto-title confirmed to already use full names - no changes needed</done>
</task>

<task type="auto">
  <name>Task 3: Create WP-CLI command to regenerate existing date titles</name>
  <files>includes/class-cli.php</files>
  <action>
Create or update includes/class-cli.php with a command to regenerate important date titles.

If class-cli.php doesn't exist, create it. If it exists, add the new command.

```php
<?php
/**
 * WP-CLI Commands for Stadion
 */

if (!defined('ABSPATH')) {
    exit;
}

if (!defined('WP_CLI') || !WP_CLI) {
    return;
}

class STADION_CLI {

    /**
     * Regenerate all Important Date titles using current naming convention.
     *
     * Uses full names instead of first names only.
     *
     * ## OPTIONS
     *
     * [--dry-run]
     * : Preview changes without saving.
     *
     * ## EXAMPLES
     *
     *     wp prm regenerate-date-titles
     *     wp prm regenerate-date-titles --dry-run
     *
     * @when after_wp_load
     */
    public function regenerate_date_titles($args, $assoc_args) {
        $dry_run = isset($assoc_args['dry-run']);

        if ($dry_run) {
            WP_CLI::log('Dry run mode - no changes will be saved.');
        }

        // Query all important_date posts
        $dates = get_posts([
            'post_type' => 'important_date',
            'posts_per_page' => -1,
            'post_status' => 'any',
        ]);

        if (empty($dates)) {
            WP_CLI::success('No important dates found.');
            return;
        }

        WP_CLI::log(sprintf('Found %d important dates to process.', count($dates)));

        $updated = 0;
        $skipped = 0;

        foreach ($dates as $date_post) {
            // Check if has custom_label - skip if custom
            $custom_label = get_field('custom_label', $date_post->ID);
            if (!empty($custom_label)) {
                WP_CLI::log(sprintf('[SKIP] #%d: Has custom label "%s"', $date_post->ID, $custom_label));
                $skipped++;
                continue;
            }

            $old_title = $date_post->post_title;

            // Generate new title using same logic as STADION_Auto_Title
            $new_title = $this->generate_date_title($date_post->ID);

            if ($old_title === $new_title) {
                WP_CLI::log(sprintf('[SAME] #%d: "%s"', $date_post->ID, $old_title));
                $skipped++;
                continue;
            }

            if ($dry_run) {
                WP_CLI::log(sprintf('[WOULD UPDATE] #%d: "%s" -> "%s"', $date_post->ID, $old_title, $new_title));
            } else {
                wp_update_post([
                    'ID' => $date_post->ID,
                    'post_title' => $new_title,
                    'post_name' => sanitize_title($new_title . '-' . $date_post->ID),
                ]);
                WP_CLI::log(sprintf('[UPDATED] #%d: "%s" -> "%s"', $date_post->ID, $old_title, $new_title));
            }
            $updated++;
        }

        if ($dry_run) {
            WP_CLI::success(sprintf('Would update %d titles. Skipped %d.', $updated, $skipped));
        } else {
            WP_CLI::success(sprintf('Updated %d titles. Skipped %d.', $updated, $skipped));
        }
    }

    /**
     * Generate date title from fields (mirrors STADION_Auto_Title logic)
     */
    private function generate_date_title($post_id) {
        // Get date type from taxonomy
        $date_types = wp_get_post_terms($post_id, 'date_type', ['fields' => 'names']);
        $type_label = !empty($date_types) ? $date_types[0] : __('Date', 'personal-crm');

        // Get related people
        $people = get_field('related_people', $post_id) ?: [];

        if (empty($people)) {
            return sprintf(__('Unnamed %s', 'personal-crm'), $type_label);
        }

        // Get full names of related people
        $names = [];
        foreach ($people as $person) {
            $person_id = is_object($person) ? $person->ID : $person;
            $full_name = html_entity_decode(get_the_title($person_id), ENT_QUOTES, 'UTF-8');
            if ($full_name && $full_name !== __('Unnamed Person', 'personal-crm')) {
                $names[] = $full_name;
            }
        }

        if (empty($names)) {
            return sprintf(__('Unnamed %s', 'personal-crm'), $type_label);
        }

        $count = count($names);

        // Get date type slug to check for wedding
        $date_type_slugs = wp_get_post_terms($post_id, 'date_type', ['fields' => 'slugs']);
        $type_slug = !empty($date_type_slugs) ? $date_type_slugs[0] : '';

        // Special handling for wedding type
        if ($type_slug === 'wedding') {
            if ($count >= 2) {
                return sprintf(__('Wedding of %s & %s', 'personal-crm'), $names[0], $names[1]);
            } elseif ($count === 1) {
                return sprintf(__('Wedding of %s', 'personal-crm'), $names[0]);
            }
        }

        if ($count === 1) {
            return sprintf(__("%s's %s", 'personal-crm'), $names[0], $type_label);
        } elseif ($count === 2) {
            return sprintf(__("%s & %s's %s", 'personal-crm'), $names[0], $names[1], $type_label);
        } else {
            $first_two = implode(', ', array_slice($names, 0, 2));
            $remaining = $count - 2;
            return sprintf(__('%s +%d %s', 'personal-crm'), $first_two, $remaining, $type_label);
        }
    }
}

WP_CLI::add_command('prm', 'STADION_CLI');
```

Then load this file in functions.php by adding to the stadion_init() function:
```php
if (defined('WP_CLI') && WP_CLI) {
    require_once get_template_directory() . '/includes/class-cli.php';
}
```

If the file already exists, just add the regenerate_date_titles method and helper.
  </action>
  <verify>
1. Run: `wp prm regenerate-date-titles --dry-run` on production
2. Verify output shows expected title changes (first name only -> full name)
3. If dry run looks good, run: `wp prm regenerate-date-titles`
4. Verify a few dates in the UI show updated full name titles
  </verify>
  <done>WP-CLI command `wp prm regenerate-date-titles` regenerates existing titles with full names</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Frontend auto-generates titles with full names
- [ ] Backend auto-title confirmed to already use full names
- [ ] WP-CLI command created and tested with --dry-run
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes
- [ ] No PHP syntax errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- New important dates show full names in titles
- WP-CLI command ready for production migration
- Phase 19 complete
</success_criteria>

<output>
After completion, create `.planning/phases/19-important-date-polish/19-02-SUMMARY.md`
</output>
