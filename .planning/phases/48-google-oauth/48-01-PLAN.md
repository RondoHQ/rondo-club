---
phase: 48-google-oauth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - composer.json
  - includes/class-google-oauth.php
  - includes/class-rest-calendar.php
  - includes/class-calendar-connections.php
  - functions.php
  - .env.example
autonomous: true
user_setup:
  - service: google-cloud
    why: "Google Calendar API requires OAuth 2.0 credentials"
    env_vars:
      - name: GOOGLE_CALENDAR_CLIENT_ID
        source: "Google Cloud Console → APIs & Services → Credentials → OAuth 2.0 Client IDs → Client ID"
      - name: GOOGLE_CALENDAR_CLIENT_SECRET
        source: "Google Cloud Console → APIs & Services → Credentials → OAuth 2.0 Client IDs → Client secret"
    account_setup:
      - url: "https://console.cloud.google.com/"
        skip_if: "Already have Google Cloud project"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID"
        location: "Google Cloud Console → APIs & Services → Credentials → Create Credentials → OAuth client ID"
        details: "Application type: Web application, Authorized redirect URI: https://[your-domain]/wp-json/prm/v1/calendar/auth/google/callback"
      - task: "Enable Google Calendar API"
        location: "Google Cloud Console → APIs & Services → Library → Search 'Google Calendar API' → Enable"
        details: "Required for calendar read access"
---

<objective>
Implement Google OAuth2 flow for calendar integration.

Purpose: Enable users to securely authorize Caelis to read their Google Calendar data using industry-standard OAuth2.
Output: Working OAuth flow that initiates authorization, handles callback, stores tokens securely, and refreshes expired tokens.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-infrastructure/47-01-SUMMARY.md
@.planning/phases/47-infrastructure/47-02-SUMMARY.md

# Source files
@includes/class-credential-encryption.php
@includes/class-rest-calendar.php
@includes/class-calendar-connections.php
@composer.json
@Calendar-Integration-Implementation-Plan.md

# Codebase context
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/INTEGRATIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install google/apiclient and create PRM_Google_OAuth class</name>
  <files>composer.json, includes/class-google-oauth.php, functions.php</files>
  <action>
1. Add "google/apiclient": "^2.15" to composer.json require section
2. Run composer update to install the dependency
3. Create includes/class-google-oauth.php with the following structure:

class PRM_Google_OAuth {
    private const SCOPES = ['https://www.googleapis.com/auth/calendar.readonly'];

    // Get Google API client instance configured with credentials
    public static function get_client(): ?Google\Client

    // Generate OAuth authorization URL with state parameter
    public static function get_auth_url(int $user_id): string

    // Exchange authorization code for tokens, return token array
    public static function handle_callback(string $code, int $user_id): array

    // Get valid access token (refresh if expired)
    public static function get_access_token(array $connection): ?string

    // Refresh expired token using refresh_token
    private static function refresh_token(string $refresh_token): array

    // Validate required environment variables are set
    public static function is_configured(): bool
}

Key implementation details:
- Use Google\Client from google/apiclient library
- Scope: https://www.googleapis.com/auth/calendar.readonly (read-only access)
- State parameter: Encode user_id + nonce for callback security (e.g., {user_id}|{nonce})
- Token storage: Use existing PRM_Credential_Encryption::encrypt() for tokens
- Access type: 'offline' to receive refresh_token
- Prompt: 'consent' to ensure refresh_token is always returned on initial auth

4. Add class to autoloader in functions.php (after class-credential-encryption.php)

Environment variables to read (as PHP constants):
- GOOGLE_CALENDAR_CLIENT_ID
- GOOGLE_CALENDAR_CLIENT_SECRET
- Redirect URI: Build dynamically from rest_url('prm/v1/calendar/auth/google/callback')
  </action>
  <verify>
- composer show google/apiclient shows installed version
- PHP syntax check: php -l includes/class-google-oauth.php
- Class loads without errors (no fatal errors in error_log)
  </verify>
  <done>
- google/apiclient ^2.15 installed via Composer
- PRM_Google_OAuth class created with all methods
- Class autoloaded in functions.php
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OAuth endpoints in REST Calendar class</name>
  <files>includes/class-rest-calendar.php</files>
  <action>
Replace the stub implementations google_auth_init and google_auth_callback with working OAuth flow:

**google_auth_init:**
1. Check PRM_Google_OAuth::is_configured() - return WP_Error if env vars missing
2. Get current user ID
3. Call PRM_Google_OAuth::get_auth_url($user_id)
4. Return JSON with auth_url for frontend to redirect to

**google_auth_callback:**
1. Get state parameter, split into user_id and nonce (format: {user_id}|{nonce})
2. Verify nonce with wp_verify_nonce($nonce, 'google_oauth_' . $user_id)
3. Check for error parameter from Google (user denied access)
4. Exchange code for tokens via PRM_Google_OAuth::handle_callback($code, $user_id)
5. On success: Create calendar connection via PRM_Calendar_Connections::add_connection()
   - provider: 'google'
   - name: 'Google Calendar' (default name, user can rename later)
   - credentials: encrypted tokens from callback
   - calendar_id: 'primary' (default, will be selectable in Settings UI)
6. Redirect to settings page with success: /settings/calendars?connected=google
7. On failure: Redirect with error: /settings/calendars?error=google_auth_failed

**Security:**
- Verify state parameter to prevent CSRF attacks
- Never expose tokens to client - store encrypted immediately
- Handle Google error responses gracefully (user denied, etc.)
  </action>
  <verify>
- PHP syntax check: php -l includes/class-rest-calendar.php
- With env vars NOT set: GET /prm/v1/calendar/auth/google returns 400 with "not configured" message
- With env vars set: GET /prm/v1/calendar/auth/google returns {auth_url: "https://accounts.google.com/..."}
  </verify>
  <done>
- google_auth_init returns auth URL or configuration error
- google_auth_callback handles code exchange and connection creation
- State parameter verified for CSRF protection
- Tokens stored encrypted via PRM_Credential_Encryption
- User redirected to settings page on completion
  </done>
</task>

<task type="auto">
  <name>Task 3: Add token refresh logic and connection update helper</name>
  <files>includes/class-google-oauth.php, includes/class-calendar-connections.php</files>
  <action>
Implement automatic token refresh in PRM_Google_OAuth::get_access_token():

1. Decrypt credentials from connection using PRM_Credential_Encryption::decrypt()
2. Check if access_token is present (fail gracefully if not)
3. Check expires_at timestamp - if token expires in < 5 minutes, refresh proactively
4. If refresh needed:
   a. Call Google API to refresh using refresh_token
   b. Get new access_token and new expires_at
   c. Update connection credentials via new helper method
   d. Return new access_token
5. If not expired, return existing access_token

Add convenience method to PRM_Calendar_Connections:
public static function update_credentials(int $user_id, string $connection_id, array $credentials): bool
- Encrypts credentials using PRM_Credential_Encryption::encrypt()
- Updates only the credentials field of the connection
- Returns success/failure boolean

Token credential structure stored in connection:
[
    'access_token' => 'ya29.xxx...',
    'refresh_token' => '1//xxx...',
    'expires_at' => 1705000000,  // Unix timestamp when token expires
    'token_type' => 'Bearer',
    'scope' => 'https://www.googleapis.com/auth/calendar.readonly'
]

Error handling:
- If refresh fails (user revoked access, network error), update connection.last_error
- Return null instead of throwing - let caller handle gracefully
- Do NOT auto-delete connection - let user see error and choose to reconnect
  </action>
  <verify>
- PHP syntax check: php -l includes/class-google-oauth.php
- PHP syntax check: php -l includes/class-calendar-connections.php
  </verify>
  <done>
- get_access_token handles automatic token refresh before expiration
- Refreshed tokens stored back to connection encrypted
- Errors set connection.last_error, return null gracefully
- update_credentials helper added to PRM_Calendar_Connections
  </done>
</task>

<task type="auto">
  <name>Task 4: Update .env.example with Google OAuth variables</name>
  <files>.env.example</files>
  <action>
Add Google Calendar OAuth section to .env.example after the Slack Integration section:

# =============================================================================
# GOOGLE CALENDAR INTEGRATION
# =============================================================================

# Google OAuth App credentials (from https://console.cloud.google.com/)
# Required for Google Calendar sync integration
#
# Setup steps:
# 1. Go to https://console.cloud.google.com/
# 2. Create or select a project
# 3. Enable Google Calendar API (APIs & Services → Library → Google Calendar API)
# 4. Configure OAuth consent screen (APIs & Services → OAuth consent screen)
#    - User type: External (or Internal for Google Workspace)
#    - App name: Your app name
#    - Scopes: Add .../auth/calendar.readonly
# 5. Create OAuth 2.0 credentials (APIs & Services → Credentials → Create Credentials)
#    - Application type: Web application
#    - Authorized redirect URI: https://your-domain.com/wp-json/prm/v1/calendar/auth/google/callback

# Client ID from Google Cloud Console OAuth 2.0 Client IDs
GOOGLE_CALENDAR_CLIENT_ID=

# Client Secret from Google Cloud Console OAuth 2.0 Client IDs
GOOGLE_CALENDAR_CLIENT_SECRET=

Keep consistent formatting with existing sections.
  </action>
  <verify>
- .env.example contains GOOGLE_CALENDAR_CLIENT_ID variable
- .env.example contains GOOGLE_CALENDAR_CLIENT_SECRET variable
- Comments explain setup steps clearly
  </verify>
  <done>
- .env.example documents Google OAuth variables
- Setup instructions explain how to obtain credentials
- Redirect URI format documented
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] composer show google/apiclient confirms library installed
- [ ] PHP linting passes on all modified files (php -l)
- [ ] PRM_Google_OAuth class loads without fatal errors
- [ ] REST endpoint /prm/v1/calendar/auth/google returns proper response
- [ ] .env.example contains Google OAuth variables with instructions
</verification>

<success_criteria>

- google/apiclient library installed via Composer
- PRM_Google_OAuth class handles complete OAuth2 flow
- Token storage uses existing PRM_Credential_Encryption
- Token refresh happens automatically before expiration
- REST endpoints return proper responses (auth URL or errors)
- Environment variables documented in .env.example
</success_criteria>

<output>
After completion, create .planning/phases/48-google-oauth/48-01-SUMMARY.md
</output>
