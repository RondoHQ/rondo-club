---
phase: 48-google-oauth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - composer.json
  - composer.lock
  - includes/class-google-oauth.php
  - includes/class-rest-calendar.php
  - functions.php
  - .env.example
autonomous: true
user_setup:
  - service: google-cloud
    why: "Google OAuth requires API credentials"
    env_vars:
      - name: GOOGLE_CALENDAR_CLIENT_ID
        source: "Google Cloud Console → APIs & Services → Credentials → OAuth 2.0 Client IDs → Client ID"
      - name: GOOGLE_CALENDAR_CLIENT_SECRET
        source: "Google Cloud Console → APIs & Services → Credentials → OAuth 2.0 Client IDs → Client Secret"
    account_setup:
      - url: "https://console.cloud.google.com/"
        skip_if: "Already have Google Cloud project"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID"
        location: "Google Cloud Console → APIs & Services → Credentials → Create Credentials → OAuth client ID"
        details: "Application type: Web application. Authorized redirect URI: https://[your-domain]/wp-json/prm/v1/calendar/auth/google/callback"
      - task: "Enable Google Calendar API"
        location: "Google Cloud Console → APIs & Services → Library → Google Calendar API"
        details: "Click Enable"
---

<objective>
Implement Google OAuth2 flow for calendar connection authentication.

Purpose: Enable users to securely connect their Google Calendar account via OAuth2, with proper token storage and automatic refresh.
Output: Working Google OAuth flow that creates calendar connections with encrypted tokens.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-infrastructure/47-01-SUMMARY.md
@.planning/phases/47-infrastructure/47-02-SUMMARY.md

# Source files
@includes/class-rest-calendar.php
@includes/class-credential-encryption.php
@includes/class-calendar-connections.php
@includes/class-rest-slack.php (OAuth pattern reference)
@Calendar-Integration-Implementation-Plan.md

# Implementation reference
The Slack OAuth implementation in class-rest-slack.php provides the pattern:
- State parameter with user_id for CSRF protection
- Transient storage for state validation
- Token encryption before storage in user meta
- Redirect to settings page on success/failure

Google OAuth differences:
- Uses google/apiclient library instead of raw HTTP
- Tokens have access_token AND refresh_token
- Access tokens expire (1 hour), need refresh logic
- Store tokens in connection credentials (not user meta directly)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install google/apiclient via Composer</name>
  <files>composer.json, composer.lock</files>
  <action>
Run `composer require google/apiclient:^2.15` to add the Google API client library.

This library provides:
- Google_Client for OAuth2 flows
- Google_Service_Calendar for calendar API access (used in Phase 49)
- Built-in token refresh handling

After installation, run `composer dump-autoload -o` to optimize the autoloader.
  </action>
  <verify>
- composer.json shows "google/apiclient": "^2.15" in require
- `ls vendor/google/apiclient` returns directory listing
- PHP can autoload Google_Client: `php -r "require 'vendor/autoload.php'; new Google_Client();"`
  </verify>
  <done>google/apiclient library installed and autoloadable</done>
</task>

<task type="auto">
  <name>Task 2: Create PRM_Google_OAuth handler class</name>
  <files>includes/class-google-oauth.php, functions.php</files>
  <action>
Create `includes/class-google-oauth.php` with the following structure:

```php
class PRM_Google_OAuth {
    private static ?Google_Client $client = null;

    /**
     * Get configured Google client
     * @return Google_Client|null Returns null if not configured
     */
    public static function get_client(): ?Google_Client {
        if (self::$client !== null) {
            return self::$client;
        }

        // Check for required constants
        if (!defined('GOOGLE_CALENDAR_CLIENT_ID') || !defined('GOOGLE_CALENDAR_CLIENT_SECRET')) {
            return null;
        }

        self::$client = new Google_Client();
        self::$client->setClientId(GOOGLE_CALENDAR_CLIENT_ID);
        self::$client->setClientSecret(GOOGLE_CALENDAR_CLIENT_SECRET);
        self::$client->setRedirectUri(rest_url('prm/v1/calendar/auth/google/callback'));
        self::$client->addScope(Google_Service_Calendar::CALENDAR_READONLY);
        self::$client->setAccessType('offline'); // Gets refresh token
        self::$client->setPrompt('consent'); // Forces consent to ensure refresh token

        return self::$client;
    }

    /**
     * Generate OAuth authorization URL with state parameter
     * @param int $user_id User ID to encode in state
     * @return string|WP_Error Authorization URL or error
     */
    public static function get_auth_url(int $user_id): string|WP_Error {
        $client = self::get_client();
        if (!$client) {
            return new WP_Error('not_configured', 'Google Calendar is not configured.');
        }

        // Generate state (same pattern as Slack OAuth)
        $random_part = wp_generate_password(32, false);
        $state = base64_encode($user_id . ':' . $random_part);
        set_transient('google_oauth_state_' . $user_id, $state, 600); // 10 minutes

        $client->setState($state);
        return $client->createAuthUrl();
    }

    /**
     * Handle OAuth callback - exchange code for tokens
     * @param string $code Authorization code from Google
     * @param string $state State parameter for CSRF validation
     * @return array{user_id: int, tokens: array}|WP_Error
     */
    public static function handle_callback(string $code, string $state): array|WP_Error {
        // Decode and validate state
        $decoded = base64_decode($state, true);
        if (!$decoded || !str_contains($decoded, ':')) {
            return new WP_Error('invalid_state', 'Invalid state parameter.');
        }

        [$user_id_str, $random] = explode(':', $decoded, 2);
        $user_id = absint($user_id_str);

        if (!$user_id) {
            return new WP_Error('invalid_state', 'Invalid user in state.');
        }

        // Verify state matches stored
        $stored = get_transient('google_oauth_state_' . $user_id);
        if ($stored !== $state) {
            return new WP_Error('state_mismatch', 'State mismatch - possible CSRF.');
        }
        delete_transient('google_oauth_state_' . $user_id);

        // Exchange code for tokens
        $client = self::get_client();
        if (!$client) {
            return new WP_Error('not_configured', 'Google Calendar is not configured.');
        }

        try {
            $tokens = $client->fetchAccessTokenWithAuthCode($code);

            if (isset($tokens['error'])) {
                return new WP_Error('token_error', $tokens['error_description'] ?? $tokens['error']);
            }

            return [
                'user_id' => $user_id,
                'tokens' => [
                    'access_token' => $tokens['access_token'],
                    'refresh_token' => $tokens['refresh_token'] ?? null,
                    'expires_at' => time() + ($tokens['expires_in'] ?? 3600),
                    'token_type' => $tokens['token_type'] ?? 'Bearer',
                ],
            ];
        } catch (Exception $e) {
            return new WP_Error('exchange_failed', $e->getMessage());
        }
    }

    /**
     * Refresh access token using refresh token
     * @param array $tokens Current token array with refresh_token
     * @return array|WP_Error Updated tokens or error
     */
    public static function refresh_tokens(array $tokens): array|WP_Error {
        if (empty($tokens['refresh_token'])) {
            return new WP_Error('no_refresh_token', 'No refresh token available.');
        }

        $client = self::get_client();
        if (!$client) {
            return new WP_Error('not_configured', 'Google Calendar is not configured.');
        }

        try {
            $client->setAccessToken($tokens);

            if ($client->isAccessTokenExpired()) {
                $new_tokens = $client->fetchAccessTokenWithRefreshToken($tokens['refresh_token']);

                if (isset($new_tokens['error'])) {
                    return new WP_Error('refresh_error', $new_tokens['error_description'] ?? $new_tokens['error']);
                }

                return [
                    'access_token' => $new_tokens['access_token'],
                    'refresh_token' => $new_tokens['refresh_token'] ?? $tokens['refresh_token'], // Keep old if not returned
                    'expires_at' => time() + ($new_tokens['expires_in'] ?? 3600),
                    'token_type' => $new_tokens['token_type'] ?? 'Bearer',
                ];
            }

            return $tokens; // Not expired, return as-is
        } catch (Exception $e) {
            return new WP_Error('refresh_failed', $e->getMessage());
        }
    }

    /**
     * Get valid access token, refreshing if needed
     * Updates connection credentials if refresh occurred
     * @param int $user_id User ID
     * @param string $connection_id Connection ID
     * @return string|WP_Error Access token or error
     */
    public static function get_valid_token(int $user_id, string $connection_id): string|WP_Error {
        $connection = PRM_Calendar_Connections::get_connection($user_id, $connection_id);
        if (!$connection) {
            return new WP_Error('not_found', 'Connection not found.');
        }

        $tokens = PRM_Credential_Encryption::decrypt($connection['credentials']);
        if (!$tokens) {
            return new WP_Error('decrypt_failed', 'Could not decrypt credentials.');
        }

        // Check if token expires in next 5 minutes
        $expires_at = $tokens['expires_at'] ?? 0;
        if ($expires_at < time() + 300) {
            $new_tokens = self::refresh_tokens($tokens);
            if (is_wp_error($new_tokens)) {
                return $new_tokens;
            }

            // Update stored credentials
            PRM_Calendar_Connections::update_connection($user_id, $connection_id, [
                'credentials' => PRM_Credential_Encryption::encrypt($new_tokens),
            ]);

            return $new_tokens['access_token'];
        }

        return $tokens['access_token'];
    }
}
```

Add to functions.php autoloader in prm_init():
```php
require_once get_template_directory() . '/includes/class-google-oauth.php';
```

Key implementation notes:
- Uses same state pattern as Slack OAuth for CSRF protection
- Stores expires_at as Unix timestamp for easy comparison
- refresh_tokens() returns existing refresh_token if Google doesn't send new one
- get_valid_token() handles automatic refresh with 5-minute buffer
  </action>
  <verify>
- File exists at includes/class-google-oauth.php
- Class autoloads without errors: check functions.php includes it
- Methods exist: get_client, get_auth_url, handle_callback, refresh_tokens, get_valid_token
  </verify>
  <done>PRM_Google_OAuth class created with OAuth flow methods</done>
</task>

<task type="auto">
  <name>Task 3: Implement Google OAuth REST endpoints</name>
  <files>includes/class-rest-calendar.php</files>
  <action>
Replace the stub implementations of `google_auth_init` and `google_auth_callback` in PRM_REST_Calendar:

**google_auth_init():**
```php
public function google_auth_init($request) {
    $user_id = get_current_user_id();
    $auth_url = PRM_Google_OAuth::get_auth_url($user_id);

    if (is_wp_error($auth_url)) {
        return $auth_url;
    }

    return rest_ensure_response([
        'oauth_url' => $auth_url,
    ]);
}
```

**google_auth_callback():**
```php
public function google_auth_callback($request) {
    $code = $request->get_param('code');
    $state = $request->get_param('state');
    $error = $request->get_param('error');

    // Handle error from Google
    if ($error) {
        wp_redirect(home_url('/settings/calendars?google_error=' . urlencode($error)));
        exit;
    }

    if (empty($code) || empty($state)) {
        wp_redirect(home_url('/settings/calendars?google_error=missing_parameters'));
        exit;
    }

    // Handle the OAuth callback
    $result = PRM_Google_OAuth::handle_callback($code, $state);

    if (is_wp_error($result)) {
        wp_redirect(home_url('/settings/calendars?google_error=' . urlencode($result->get_error_message())));
        exit;
    }

    // Create the calendar connection
    $user_id = $result['user_id'];
    $tokens = $result['tokens'];

    // Get user info for connection name
    $client = PRM_Google_OAuth::get_client();
    $client->setAccessToken($tokens);

    // Encrypt credentials
    $encrypted = PRM_Credential_Encryption::encrypt($tokens);

    // Create connection
    $connection = [
        'provider'       => 'google',
        'name'           => 'Google Calendar', // Default name, can be updated later
        'calendar_id'    => 'primary', // Default to primary, user selects specific calendar in Phase 49
        'credentials'    => $encrypted,
        'sync_enabled'   => true,
        'auto_log'       => true,
        'sync_from_days' => 90,
        'last_sync'      => null,
        'last_error'     => null,
    ];

    $connection_id = PRM_Calendar_Connections::add_connection($user_id, $connection);

    // Redirect to settings with success
    wp_redirect(home_url('/settings/calendars?google_connected=' . $connection_id));
    exit;
}
```

The callback creates a connection immediately after successful OAuth. Users can later:
1. Rename the connection
2. Select which calendar to sync (Phase 49)
3. Adjust sync settings
  </action>
  <verify>
- GET /prm/v1/calendar/auth/google returns { oauth_url: "..." } when configured
- GET /prm/v1/calendar/auth/google returns error when not configured
- Callback redirects to /settings/calendars with appropriate params
  </verify>
  <done>Google OAuth endpoints implemented, creating connection on successful auth</done>
</task>

<task type="auto">
  <name>Task 4: Document environment variables</name>
  <files>.env.example</files>
  <action>
Add the following to .env.example under a new "# Google Calendar Integration" section:

```
# Google Calendar Integration
# Create OAuth 2.0 credentials at https://console.cloud.google.com/
# Required scopes: https://www.googleapis.com/auth/calendar.readonly
GOOGLE_CALENDAR_CLIENT_ID=your-client-id.apps.googleusercontent.com
GOOGLE_CALENDAR_CLIENT_SECRET=your-client-secret
```

These constants should be defined in wp-config.php:
```php
define('GOOGLE_CALENDAR_CLIENT_ID', getenv('GOOGLE_CALENDAR_CLIENT_ID'));
define('GOOGLE_CALENDAR_CLIENT_SECRET', getenv('GOOGLE_CALENDAR_CLIENT_SECRET'));
```
  </action>
  <verify>
- .env.example contains GOOGLE_CALENDAR_CLIENT_ID documentation
- .env.example contains GOOGLE_CALENDAR_CLIENT_SECRET documentation
- Comments explain how to obtain credentials
  </verify>
  <done>Environment variables documented in .env.example</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `composer show google/apiclient` shows installed version ^2.15
- [ ] PHP class PRM_Google_OAuth loads without errors
- [ ] GET /prm/v1/calendar/auth/google returns oauth_url (when configured) or error (when not)
- [ ] .env.example documents Google Calendar credentials
</verification>

<success_criteria>

- google/apiclient library installed
- PRM_Google_OAuth class handles auth URL generation, code exchange, token refresh
- REST endpoints call OAuth handler instead of returning 501
- Environment configuration documented
- Token refresh logic preserves refresh_token across renewals
</success_criteria>

<output>
After completion, create `.planning/phases/48-google-oauth/48-01-SUMMARY.md`
</output>
