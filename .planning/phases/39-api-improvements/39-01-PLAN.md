---
phase: 39-api-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-auto-title.php
  - src/components/ImportantDateModal.jsx
  - includes/class-rest-api.php
  - src/hooks/usePeople.js
autonomous: true
---

<objective>
Fix three API/data-related bugs: important date auto-title overwriting user edits, search not prioritizing first name matches, and dashboard cache not invalidating on todo creation.

Purpose: Improve data integrity and UX by respecting user edits, improving search relevance, and ensuring dashboard shows current todo counts.
Output: Bug fixes in PHP backend and React frontend with proper cache invalidation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@includes/class-auto-title.php
@includes/class-rest-api.php
@src/components/ImportantDateModal.jsx
@src/hooks/usePeople.js
@src/hooks/useDashboard.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix important date auto-title overwriting custom names</name>
  <files>includes/class-auto-title.php, src/components/ImportantDateModal.jsx</files>
  <action>
**Problem:** When user edits an important date and changes the title, the `auto_generate_date_title()` method runs on save and overwrites the title with auto-generated text (unless `custom_label` ACF field is set).

**Backend fix (class-auto-title.php):**
The backend already has logic to respect `custom_label` field (lines 70-77). The issue is that the frontend doesn't send a `custom_label` value when the user edits the title.

When comparing the submitted title against the auto-generated title:
1. In `auto_generate_date_title()`, BEFORE regenerating, compare current `post_title` with what would be auto-generated
2. If they differ (user has customized it), set `custom_label` meta to the current title and skip regeneration
3. This preserves backward compatibility - existing dates with custom titles will be preserved

Add this check near the top of `auto_generate_date_title()` after the autosave/revision check:
```php
// Check if user has set a custom title (different from what we'd auto-generate)
$current_title = get_the_title($post_id);
$auto_title = $this->generate_date_title_from_fields($post_id);

// If current title differs from auto-generated, user has customized it
// Set custom_label so it persists and skip auto-generation
if (!empty($current_title) && $current_title !== $auto_title && empty(get_field('custom_label', $post_id))) {
    update_field('custom_label', $current_title, $post_id);
    return; // Respect user's custom title
}
```

**Frontend fix (ImportantDateModal.jsx):**
The frontend auto-title effect (lines 138-179) has a pattern-matching approach that's fragile. Instead:
1. Add a `hasUserEditedTitle` ref that tracks if user manually edited the title field
2. When form resets on edit mode, set `hasUserEditedTitle.current = false`
3. Add an onChange handler to the title input that sets `hasUserEditedTitle.current = true`
4. In the useEffect for auto-generation, check `hasUserEditedTitle.current` - if true, skip auto-generation

Replace the pattern-matching `isAutoGenerated` logic with the ref-based approach:
```jsx
const hasUserEditedTitle = useRef(false);

// In the reset useEffect (around line 182), add:
hasUserEditedTitle.current = false;

// In the auto-title useEffect:
if (hasUserEditedTitle.current) return; // User has edited title, don't auto-generate
```

Add onChange to title input to track user edits (in the JSX around line 340+):
```jsx
{...register('title', {
  onChange: () => { hasUserEditedTitle.current = true; }
})}
```
  </action>
  <verify>
1. Create a new important date (Birthday for a person) - title should auto-generate as "Person's Birthday"
2. Edit the important date, change title to "Custom Birthday Name"
3. Save - title should remain "Custom Birthday Name"
4. Reload page, edit again - title should still be "Custom Birthday Name"
5. Change date_type or related_people - title should NOT be overwritten since user customized it
  </verify>
  <done>User can edit important date titles and their changes persist through saves. Auto-title only applies to new dates or dates that haven't been customized.</done>
</task>

<task type="auto">
  <name>Task 2: Prioritize first name in search results</name>
  <files>includes/class-rest-api.php</files>
  <action>
**Problem:** The `global_search()` method uses WordPress default `s` parameter which doesn't prioritize first name matches. Users typically search by first name, so "John" should rank "John Smith" higher than "Sarah Johnson" (where John appears in notes).

**Fix in class-rest-api.php `global_search()` method (around line 592):**

Replace the simple `'s' => $query` search with a custom scoring approach:

1. Instead of using `'s' => $query`, query with meta_query for first_name, last_name, and also keep `s` for broader matches
2. Score results: exact first_name match = 100, first_name starts with query = 80, last_name match = 50, title match = 40, other (s param) = 10
3. Sort by score descending

Replace the people search section with:
```php
// Search people with scoring
$people_results = [];

// Query 1: First name exact match or starts with
$first_name_matches = get_posts([
    'post_type'      => 'person',
    'posts_per_page' => 20,
    'post_status'    => 'publish',
    'meta_query'     => [
        [
            'key'     => 'first_name',
            'value'   => $query,
            'compare' => 'LIKE',
        ],
    ],
]);

foreach ($first_name_matches as $person) {
    $first_name = strtolower(get_field('first_name', $person->ID) ?: '');
    $query_lower = strtolower($query);

    // Score: exact = 100, starts with = 80, contains = 60
    if ($first_name === $query_lower) {
        $score = 100;
    } elseif (strpos($first_name, $query_lower) === 0) {
        $score = 80;
    } else {
        $score = 60;
    }

    $people_results[$person->ID] = [
        'person' => $person,
        'score'  => $score,
    ];
}

// Query 2: Last name matches (lower priority)
$last_name_matches = get_posts([
    'post_type'      => 'person',
    'posts_per_page' => 20,
    'post_status'    => 'publish',
    'meta_query'     => [
        [
            'key'     => 'last_name',
            'value'   => $query,
            'compare' => 'LIKE',
        ],
    ],
]);

foreach ($last_name_matches as $person) {
    if (!isset($people_results[$person->ID])) {
        $people_results[$person->ID] = [
            'person' => $person,
            'score'  => 40,
        ];
    }
}

// Query 3: General WordPress search (catches title, content)
$general_matches = get_posts([
    'post_type'      => 'person',
    's'              => $query,
    'posts_per_page' => 20,
    'post_status'    => 'publish',
]);

foreach ($general_matches as $person) {
    if (!isset($people_results[$person->ID])) {
        $people_results[$person->ID] = [
            'person' => $person,
            'score'  => 20,
        ];
    }
}

// Sort by score descending, take top 10
uasort($people_results, function($a, $b) {
    return $b['score'] - $a['score'];
});

$people_results = array_slice($people_results, 0, 10, true);

foreach ($people_results as $item) {
    $results['people'][] = $this->format_person_summary($item['person']);
}
```

Leave the companies search as-is (name search is sufficient there).
  </action>
  <verify>
1. Create two people: "John Smith" and "Sarah Johnson" (with "John" in notes)
2. Search for "John" - "John Smith" should appear first
3. Search for "Sarah" - "Sarah Johnson" should appear first
4. Search for "Smith" - "John Smith" should appear (via last name)
5. Search for partial "Joh" - "John Smith" should appear first (starts with match)
  </verify>
  <done>Search results are ranked with first name matches scoring highest, followed by last name, then general content matches.</done>
</task>

<task type="auto">
  <name>Task 3: Invalidate dashboard cache on todo mutations</name>
  <files>src/hooks/usePeople.js</files>
  <action>
**Problem:** There are two sets of todo mutation hooks:
- `useDashboard.js`: `useUpdateTodo`, `useDeleteTodo` - these DO invalidate `['dashboard']` query
- `usePeople.js`: `useCreateTodo`, `useUpdateTodo`, `useDeleteTodo` - these DON'T invalidate dashboard

When creating/updating/deleting todos from PersonDetail page (which uses `usePeople.js` hooks), the dashboard stats become stale.

**Fix in src/hooks/usePeople.js:**

Add dashboard cache invalidation to all three todo mutation hooks:

1. In `useCreateTodo()` (around line 342), add to onSuccess:
```javascript
queryClient.invalidateQueries({ queryKey: ['dashboard'] });
queryClient.invalidateQueries({ queryKey: ['todos'] }); // Global todos list
```

2. In `useUpdateTodo()` (around line 354), add to onSuccess:
```javascript
queryClient.invalidateQueries({ queryKey: ['dashboard'] });
queryClient.invalidateQueries({ queryKey: ['todos'] }); // Global todos list
```

3. In `useDeleteTodo()` (around line 368), add to onSuccess:
```javascript
queryClient.invalidateQueries({ queryKey: ['dashboard'] });
queryClient.invalidateQueries({ queryKey: ['todos'] }); // Global todos list
```

This ensures dashboard stats (open_todos_count, awaiting_todos_count) and the global todos list stay in sync regardless of which page the todo was modified from.
  </action>
  <verify>
1. Open dashboard, note the open todos count
2. Navigate to a person's detail page
3. Create a new open todo for that person
4. Navigate back to dashboard - open todos count should be incremented
5. Mark the todo as completed from person detail page
6. Check dashboard - open todos count should be decremented
7. Delete a todo from person detail - dashboard should reflect the change
  </verify>
  <done>Dashboard stats update immediately when todos are created, updated, or deleted from any page in the app.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Important date title edits persist after save
- [ ] Search for first name returns that person first
- [ ] Dashboard counts update when todos change from PersonDetail
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No regressions in existing functionality
- User-edited important date titles persist
- First name searches rank correctly
- Dashboard stays in sync with todo changes
</success_criteria>

<output>
After completion, create `.planning/phases/39-api-improvements/39-01-SUMMARY.md`
</output>
