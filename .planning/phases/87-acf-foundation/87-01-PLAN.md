---
phase: 87-acf-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-custom-fields-manager.php
  - functions.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PHP can create a custom field definition for People that persists in database"
    - "PHP can create a custom field definition for Teams that persists in database"
    - "PHP can update an existing field definition"
    - "PHP can deactivate a field without deleting stored data"
    - "Field keys auto-generate from labels with uniqueness"
  artifacts:
    - path: "includes/class-custom-fields-manager.php"
      provides: "CustomFields Manager class with CRUD operations"
      exports: ["Stadion\\CustomFields\\Manager"]
      min_lines: 200
  key_links:
    - from: "includes/class-custom-fields-manager.php"
      to: "acf_import_field_group()"
      via: "ACF database persistence API"
      pattern: "acf_import_field_group"
    - from: "includes/class-custom-fields-manager.php"
      to: "acf_update_field()"
      via: "ACF field CRUD"
      pattern: "acf_update_field"
    - from: "functions.php"
      to: "Stadion\\CustomFields\\Manager"
      via: "use statement and initialization"
      pattern: "use Stadion\\\\CustomFields\\\\Manager"
---

<objective>
Create the PHP CustomFields Manager class that provides programmatic CRUD operations for ACF custom field definitions.

Purpose: This is the foundation for the entire Custom Fields feature. It provides the backend infrastructure that the Settings UI and Detail View will use to manage user-defined custom fields for People and Teams.

Output: A fully functional PHP class that can create, read, update, and deactivate custom field definitions using ACF's database persistence API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87-acf-foundation/87-RESEARCH.md

Reference files:
@functions.php (for initialization pattern)
@includes/class-post-types.php (for namespace pattern example)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomFields Manager class</name>
  <files>includes/class-custom-fields-manager.php</files>
  <action>
Create a new PHP class `Stadion\CustomFields\Manager` in `includes/class-custom-fields-manager.php` that provides:

**Class structure:**
```php
namespace Stadion\CustomFields;

class Manager {
    // Constants for supported post types
    const SUPPORTED_POST_TYPES = ['person', 'team'];

    // Group key pattern: group_custom_fields_{post_type}
    // Field key pattern: field_custom_{post_type}_{slug}
}
```

**Methods to implement:**

1. `__construct()` - No hooks needed, just initialization

2. `ensure_field_group(string $post_type): array` - Creates field group if not exists, returns group array
   - Validate post_type is in SUPPORTED_POST_TYPES
   - Check if group exists via `acf_get_field_group('group_custom_fields_{post_type}')`
   - If not exists, create via `acf_import_field_group()` with:
     - key: `group_custom_fields_{post_type}`
     - title: 'Custom Fields'
     - location: post_type == $post_type
     - menu_order: 100 (after built-in groups)
     - show_in_rest: 1
     - active: true
   - Return the field group array

3. `generate_field_key(string $label, string $post_type): string` - Generate unique field key
   - Sanitize label to slug via `sanitize_title()`
   - Create base key: `field_custom_{post_type}_{slug}`
   - If key exists (check via `acf_get_field()`), append unique suffix: `_{substr(uniqid(), -6)}`
   - Return the key

4. `create_field(string $post_type, array $field_config): array|WP_Error` - Create new field
   - Validate post_type
   - Ensure field group exists
   - Required field_config keys: `label`, `type`
   - Optional: `name` (defaults to sanitize_title of label), `instructions`, `required`, `choices`, `default_value`, `placeholder`
   - Generate field key via `generate_field_key()`
   - Build field array with:
     - key, label, name, type from config
     - parent: field group post ID (get from `ensure_field_group()['ID']`)
     - instructions, required, choices etc. if provided
   - Call `acf_update_field($field)` to persist
   - Return created field array or WP_Error on failure

5. `update_field(string $field_key, array $updates): array|WP_Error` - Update existing field
   - Get existing field via `acf_get_field($field_key)`
   - Return WP_Error if not found
   - Only allow updating: label, name, instructions, required, choices, default_value, placeholder
   - Do NOT allow changing: key, type, parent (these are immutable)
   - Merge allowed updates into existing field
   - Call `acf_update_field($field)` to persist
   - Return updated field array

6. `deactivate_field(string $field_key): array|WP_Error` - Soft delete field
   - Get existing field via `acf_get_field($field_key)`
   - Return WP_Error if not found
   - Set `$field['active'] = 0`
   - Call `acf_update_field($field)` to persist
   - Return updated field array

7. `reactivate_field(string $field_key): array|WP_Error` - Restore deactivated field
   - Same as deactivate but sets `active = 1`

8. `get_fields(string $post_type, bool $include_inactive = false): array` - Get all custom fields
   - Validate post_type
   - Get group key: `group_custom_fields_{post_type}`
   - Call `acf_get_fields($group_key)` - returns array or false
   - If include_inactive is false, filter out fields where active === 0
   - Return fields array (empty array if none)

9. `get_field(string $field_key): array|false` - Get single field by key
   - Wrapper around `acf_get_field($field_key)`

**Important implementation notes:**
- All ACF functions (`acf_get_field_group`, `acf_import_field_group`, `acf_update_field`, `acf_get_fields`, `acf_get_field`) are ACF Pro database persistence functions
- Field groups are stored as `acf-field-group` CPT posts
- Fields are stored as `acf-field` CPT posts with parent = field group post ID
- The `active` flag on fields controls whether ACF renders them - setting to 0 hides field but preserves stored values in wp_postmeta

**Error handling:**
- Return WP_Error for invalid post_type, missing required config, field not found
- Use error codes like: 'invalid_post_type', 'missing_required', 'field_not_found'
  </action>
  <verify>
Run `wp eval "require_once get_template_directory() . '/vendor/autoload.php'; \$m = new Stadion\CustomFields\Manager(); var_dump(\$m->ensure_field_group('person'));"` to verify class loads and can create field group.
  </verify>
  <done>
Manager class exists at includes/class-custom-fields-manager.php with all 9 methods implemented. Class can create field groups and fields that persist in the database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Initialize Manager in functions.php</name>
  <files>functions.php</files>
  <action>
Add the CustomFields Manager to the initialization flow in functions.php:

1. Add use statement at top with other Stadion imports:
   ```php
   use Stadion\CustomFields\Manager as CustomFieldsManager;
   ```

2. Add backward compatibility alias with other aliases:
   ```php
   if ( ! class_exists( 'RONDO_Custom_Fields_Manager' ) ) {
       class_alias( CustomFieldsManager::class, 'RONDO_Custom_Fields_Manager' );
   }
   ```

Note: The Manager class is stateless and doesn't need to be instantiated in rondo_init(). It will be instantiated by the REST API class when needed (Plan 02). The alias ensures backward compatibility if any code references the old class name pattern.
  </action>
  <verify>
Run `npm run lint` in stadion directory (for PHP linting via composer).
Run `wp eval "class_exists('Stadion\CustomFields\Manager') ? print('Class exists') : print('Class missing');"` to verify autoloading works.
  </verify>
  <done>
functions.php has use statement for CustomFields\Manager and backward compatibility alias. Class autoloads correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write integration tests for Manager class</name>
  <files>tests/wpunit/CustomFields/ManagerTest.php</files>
  <action>
Create integration tests for the CustomFields Manager to verify all CRUD operations work correctly with ACF:

```php
namespace Tests\WPUnit\CustomFields;

use Stadion\CustomFields\Manager;
use WP_Error;

class ManagerTest extends \Codeception\TestCase\WPTestCase {
    private Manager $manager;

    public function setUp(): void {
        parent::setUp();
        $this->manager = new Manager();
        // Clean up any test field groups from previous runs
        $this->cleanup_test_fields();
    }

    public function tearDown(): void {
        $this->cleanup_test_fields();
        parent::tearDown();
    }

    private function cleanup_test_fields(): void {
        // Delete test field groups if they exist
        foreach (['person', 'team'] as $post_type) {
            $group = acf_get_field_group("group_custom_fields_{$post_type}");
            if ($group) {
                acf_delete_field_group($group['ID']);
            }
        }
    }
}
```

**Test methods to implement:**

1. `test_ensure_field_group_creates_for_person()` - Creates group, verify it exists
2. `test_ensure_field_group_creates_for_team()` - Creates group for team
3. `test_ensure_field_group_rejects_invalid_post_type()` - Returns error for 'invalid_type'
4. `test_ensure_field_group_returns_existing()` - Second call returns same group

5. `test_generate_field_key_creates_unique_key()` - Verify pattern `field_custom_person_*`
6. `test_generate_field_key_handles_duplicate_labels()` - Same label gets unique suffix

7. `test_create_field_success()` - Create text field, verify persisted
8. `test_create_field_requires_label()` - Missing label returns WP_Error
9. `test_create_field_requires_type()` - Missing type returns WP_Error

10. `test_update_field_changes_label()` - Update label, verify changed
11. `test_update_field_preserves_key()` - Key cannot be changed via update
12. `test_update_field_returns_error_for_missing_field()` - Invalid key returns error

13. `test_deactivate_field_sets_inactive()` - active = 0 after deactivate
14. `test_reactivate_field_sets_active()` - active = 1 after reactivate

15. `test_get_fields_returns_active_only_by_default()` - Inactive fields filtered
16. `test_get_fields_includes_inactive_when_requested()` - include_inactive = true

Create in `tests/wpunit/CustomFields/` directory (create directory if needed).
  </action>
  <verify>
Run `composer test` or `vendor/bin/codecept run wpunit tests/wpunit/CustomFields/ManagerTest.php` to verify all tests pass.
  </verify>
  <done>
Integration tests exist at tests/wpunit/CustomFields/ManagerTest.php and all 16 tests pass, verifying Manager CRUD operations work correctly with ACF database persistence.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Manager class loads correctly:**
   ```bash
   wp eval "require_once get_template_directory() . '/vendor/autoload.php'; echo class_exists('Stadion\CustomFields\Manager') ? 'OK' : 'FAIL';"
   ```

2. **Can create field group:**
   ```bash
   wp eval "
   \$m = new Stadion\CustomFields\Manager();
   \$g = \$m->ensure_field_group('person');
   echo isset(\$g['ID']) ? 'Group created: ' . \$g['ID'] : 'FAIL';
   "
   ```

3. **Can create field:**
   ```bash
   wp eval "
   \$m = new Stadion\CustomFields\Manager();
   \$f = \$m->create_field('person', ['label' => 'Test Field', 'type' => 'text']);
   echo is_array(\$f) && isset(\$f['key']) ? 'Field created: ' . \$f['key'] : 'FAIL';
   "
   ```

4. **Field persists in database:**
   ```bash
   wp eval "
   \$m = new Stadion\CustomFields\Manager();
   \$fields = \$m->get_fields('person');
   echo count(\$fields) > 0 ? 'Fields found: ' . count(\$fields) : 'No fields';
   "
   ```

5. **Integration tests pass:**
   ```bash
   composer test -- tests/wpunit/CustomFields/ManagerTest.php
   ```
</verification>

<success_criteria>
1. Manager class exists at includes/class-custom-fields-manager.php with namespace Stadion\CustomFields\Manager
2. Class has all 9 methods: ensure_field_group, generate_field_key, create_field, update_field, deactivate_field, reactivate_field, get_fields, get_field
3. functions.php has use statement and backward compatibility alias
4. Field groups and fields persist to database (survive page reload)
5. Deactivated fields preserve stored data in wp_postmeta
6. All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/87-acf-foundation/87-01-SUMMARY.md`
</output>
