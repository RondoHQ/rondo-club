---
phase: 113-frontend-pagination
plan: 02
type: execute
wave: 2
depends_on:
  - 113-01
files_modified:
  - src/components/Pagination.jsx
  - src/pages/People/PeopleList.jsx
  - src/hooks/usePeople.js
autonomous: true

must_haves:
  truths:
    - "User sees 100 people per page, not all 1400+ at once"
    - "User can navigate between pages using prev/next buttons"
    - "User can click on page numbers to jump to specific page"
    - "User sees page info: 'Page X of Y' and 'Showing X-Y of Z people'"
    - "Changing any filter resets view to page 1"
    - "Loading indicator shows while fetching page data"
    - "Empty state displays when no people match filters"
    - "Previous page data stays visible during page navigation (no flash)"
  artifacts:
    - path: "src/components/Pagination.jsx"
      provides: "Reusable pagination controls component"
      min_lines: 80
    - path: "src/pages/People/PeopleList.jsx"
      provides: "Paginated people list with server-side data"
      contains: "useFilteredPeople"
  key_links:
    - from: "src/pages/People/PeopleList.jsx"
      to: "useFilteredPeople hook"
      via: "React hook import"
      pattern: "useFilteredPeople"
    - from: "src/pages/People/PeopleList.jsx"
      to: "Pagination component"
      via: "Component import"
      pattern: "import.*Pagination"
    - from: "src/hooks/usePeople.js"
      to: "/stadion/v1/people/filtered"
      via: "API client method"
      pattern: "getFilteredPeople"
---

<objective>
Integrate server-side pagination into PeopleList with navigation controls.

Purpose: Replace client-side "load all then filter" with server-side paginated queries, enabling the People list to scale beyond 1400+ contacts efficiently.

Output: PeopleList displays 100 people per page with prev/next/page number navigation, filter-aware pagination reset, and proper loading/empty states.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/111-server-side-foundation/111-02-SUMMARY.md
@.planning/phases/113-frontend-pagination/113-RESEARCH.md
@src/pages/People/PeopleList.jsx
@src/hooks/usePeople.js
@src/api/client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pagination component</name>
  <files>src/components/Pagination.jsx</files>
  <action>
Create a new reusable Pagination component at `src/components/Pagination.jsx`:

**Props:**
- `currentPage` (number) - Current page number (1-indexed)
- `totalPages` (number) - Total number of pages
- `totalItems` (number) - Total number of items
- `itemsPerPage` (number, default 100) - Items per page
- `onPageChange` (function) - Callback when page changes, receives new page number

**Features:**
1. **Page info text** (left side):
   - "Tonen {start}-{end} van {total} leden" (Dutch)
   - Calculate start = (currentPage - 1) * itemsPerPage + 1
   - Calculate end = Math.min(currentPage * itemsPerPage, totalItems)

2. **Page controls** (right side):
   - Previous button with ChevronLeft icon, disabled when on page 1
   - Page number buttons with ellipsis for many pages
   - Next button with ChevronRight icon, disabled when on last page

3. **Page number display logic** (for totalPages > 7):
   - Always show first page (1)
   - Show ellipsis (...) if currentPage > 3
   - Show currentPage-1, currentPage, currentPage+1 (when applicable)
   - Show ellipsis (...) if currentPage < totalPages - 2
   - Always show last page

4. **Styling:**
   - Use Tailwind classes matching existing Stadion UI patterns
   - Current page button: `bg-accent-600 text-white`
   - Other page buttons: `hover:bg-gray-100 dark:hover:bg-gray-700`
   - Disabled buttons: `opacity-50 cursor-not-allowed`
   - Responsive: Stack info text above controls on mobile

5. **Accessibility:**
   - `aria-label` on prev/next buttons
   - `aria-current="page"` on current page button
   - Button elements (not links) for page numbers

Import icons from lucide-react: `ChevronLeft`, `ChevronRight`

Example usage:
```jsx
<Pagination
  currentPage={2}
  totalPages={15}
  totalItems={1427}
  onPageChange={(page) => setPage(page)}
/>
```
  </action>
  <verify>
Create test file or verify manually:
```bash
npm run build  # Ensure component compiles without errors
```

Manual verification will happen in Task 3 integration.
  </verify>
  <done>
- Pagination.jsx exists with all required props
- Page info text shows "Tonen X-Y van Z leden"
- Prev/next buttons work with proper disabled states
- Page numbers display with ellipsis pattern
- Styling matches Stadion UI (dark mode support)
- Accessible markup with aria attributes
  </done>
</task>

<task type="auto">
  <name>Task 2: Update useFilteredPeople hook with birth year params</name>
  <files>src/hooks/usePeople.js</files>
  <action>
Extend the `useFilteredPeople` hook to support birth year filtering (already exists on backend):

1. Add `birthYearFrom` and `birthYearTo` to the params object:
```javascript
const params = {
  page: filters.page || 1,
  per_page: filters.perPage || 100,
  labels: filters.labels || [],
  ownership: filters.ownership || 'all',
  modified_days: filters.modifiedDays || null,
  birth_year_from: filters.birthYearFrom || null,  // ADD
  birth_year_to: filters.birthYearTo || null,      // ADD
  orderby: filters.orderby || 'first_name',
  order: filters.order || 'asc',
};
```

2. Update the JSDoc comment to document these new parameters:
```javascript
 * @param {number} filters.birthYearFrom - Filter by birth year (minimum, inclusive)
 * @param {number} filters.birthYearTo - Filter by birth year (maximum, inclusive)
```

This enables the PeopleList to pass birth year filters to the server.

Note: The hook already exists from Phase 111-02, we're just adding the missing parameters.
  </action>
  <verify>
```bash
npm run build  # Ensure no TypeScript/compilation errors
```

Verify the params object includes birth_year_from and birth_year_to.
  </verify>
  <done>
- useFilteredPeople accepts birthYearFrom and birthYearTo parameters
- Parameters are converted to snake_case for backend (birth_year_from, birth_year_to)
- Hook documentation updated
  </done>
</task>

<task type="auto">
  <name>Task 3a: Convert PeopleList to server-side data</name>
  <files>src/pages/People/PeopleList.jsx</files>
  <action>
Convert PeopleList.jsx to use server-side pagination data instead of client-side filtering. This task focuses on state and data changes.

**1. Update imports (top of file):**
```javascript
import { useFilteredPeople, useCreatePerson, useBulkUpdatePeople } from '@/hooks/usePeople';
import Pagination from '@/components/Pagination';
// Remove: usePeople import (keep useFilteredPeople)
```

**2. Add page state (around line 425):**
```javascript
const [page, setPage] = useState(1);
```

**3. Convert label filter to use IDs instead of names:**
Currently `selectedLabels` stores label names (strings). The backend expects term IDs.
Change to store term IDs:
```javascript
const [selectedLabelIds, setSelectedLabelIds] = useState([]);
```
Update `handleLabelToggle` to toggle IDs:
```javascript
const handleLabelToggle = (labelId) => {
  setSelectedLabelIds(prev =>
    prev.includes(labelId)
      ? prev.filter(id => id !== labelId)
      : [...prev, labelId]
  );
};
```

**4. Replace usePeople with useFilteredPeople (around line 440):**
```javascript
const { data, isLoading, isFetching, error } = useFilteredPeople({
  page,
  perPage: 100,
  labels: selectedLabelIds,
  ownership: ownershipFilter,
  modifiedDays: lastModifiedFilter ? parseInt(lastModifiedFilter, 10) : null,
  birthYearFrom: selectedBirthYear ? parseInt(selectedBirthYear, 10) : null,
  birthYearTo: selectedBirthYear ? parseInt(selectedBirthYear, 10) : null, // Same year for exact match
  orderby: sortField.startsWith('custom_') ? sortField : sortField === 'organization' || sortField === 'labels' ? 'first_name' : sortField,
  order: sortOrder,
});

// Extract data from response
const people = data?.people || [];
const totalPeople = data?.total || 0;
const totalPages = data?.total_pages || 0;
```

**5. Reset page to 1 when filters change:**
Add useEffect after the filter state declarations:
```javascript
useEffect(() => {
  setPage(1);
}, [selectedLabelIds, selectedBirthYear, lastModifiedFilter, ownershipFilter, sortField, sortOrder]);
```

**6. Remove client-side filtering/sorting:**
- Delete the `filteredAndSortedPeople` useMemo (lines ~546-605) - backend handles this
- Delete the `sortedPeople` useMemo (lines ~706-802) - backend handles this
- Update all references from `sortedPeople` to `people`
- Update all references from `filteredAndSortedPeople` to `people`

**7. Update availableBirthYears:**
Generate reasonable birth year range instead of deriving from data:
```javascript
const availableBirthYears = useMemo(() => {
  const currentYear = new Date().getFullYear();
  const years = [];
  for (let year = currentYear - 5; year >= 1950; year--) {
    years.push(year);
  }
  return years;
}, []);
```

**8. Update hasActiveFilters check:**
```javascript
const hasActiveFilters = selectedLabelIds.length > 0 || selectedBirthYear || lastModifiedFilter || ownershipFilter !== 'all';
```

**9. Update clearFilters:**
```javascript
const clearFilters = () => {
  setSelectedLabelIds([]);
  setSelectedBirthYear('');
  setLastModifiedFilter('');
  setOwnershipFilter('all');
  // page will auto-reset via useEffect
};
```

**10. Update selection logic:**
- Clear selection when page changes (add `page` to the useEffect that clears selection)
- Update `toggleSelectAll` to use `people` instead of `filteredAndSortedPeople`
- Update `isAllSelected` and `isSomeSelected` to use `people`

**11. Update empty state checks:**
- Change `people?.length === 0` to check `data?.total === 0` for "no people at all"
- Change filter empty state to check `people.length === 0 && totalPeople === 0 && hasActiveFilters`

**12. Update team fetching:**
Update teamIds useMemo to use `people`:
```javascript
const teamIds = useMemo(() => {
  if (!people) return [];
  const ids = people
    .map(person => getCurrentTeamId(person))
    .filter(Boolean);
  return [...new Set(ids)];
}, [people]);
```
Similarly update `personTeamMap` to use `people`.

**13. Handle special sort fields:**
For 'organization' and 'labels' sorting, fall back to first_name sorting (already in step 4).

**Important notes:**
- The backend returns people with: id, first_name, last_name, modified, thumbnail, labels (names array)
- For bulk selection, we need person.id which is available
- Team column will show '-' for all rows (known limitation - requires backend enhancement)
  </action>
  <verify>
```bash
npm run build  # Must pass with no errors
```
  </verify>
  <done>
- PeopleList uses useFilteredPeople instead of usePeople
- Page state exists and changes trigger API refetch
- Filter changes reset page to 1
- Selection clears when page or filters change
- Label filter uses term IDs (not names)
- Client-side filtering/sorting removed
  </done>
</task>

<task type="auto">
  <name>Task 3b: Add pagination UI components</name>
  <files>src/pages/People/PeopleList.jsx</files>
  <action>
Add pagination UI components and loading states to PeopleList.jsx. This task builds on Task 3a's data changes.

**1. Update filter UI for label IDs:**
In the Labels filter section (around line 859-889), change to use label IDs.

Note: `availableLabelsWithIds` already exists (line 478). It comes from the `labelsData` query result (line 468-474) which fetches from `wpApi.getPersonLabels()`. Each label object has `{id, name, slug, count}` properties. No new code needed for this data source.

Update the filter checkbox rendering:
```jsx
{availableLabelsWithIds.map(label => (
  <label key={label.id} className="...">
    <input
      type="checkbox"
      checked={selectedLabelIds.includes(label.id)}
      onChange={() => handleLabelToggle(label.id)}
      className="sr-only"
    />
    {/* checkbox visual */}
    <span>{label.name}</span>
  </label>
))}
```

**2. Update filter chips display:**
Change the active filter chips (around line 982-1030) to show label names from IDs:
```jsx
{selectedLabelIds.map(labelId => {
  const label = availableLabelsWithIds.find(l => l.id === labelId);
  return label ? (
    <span key={labelId} className="...">
      {label.name}
      <button onClick={() => handleLabelToggle(labelId)}>
        <X className="w-3 h-3" />
      </button>
    </span>
  ) : null;
})}
```

**3. Add loading indicator for page navigation:**
Show subtle loading indicator when `isFetching` is true (indicates loading new page while showing previous data):
```jsx
{isFetching && !isLoading && (
  <div className="fixed bottom-4 right-4 bg-white dark:bg-gray-800 shadow-lg rounded-lg px-4 py-2 flex items-center gap-2">
    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-accent-600" />
    <span className="text-sm text-gray-600 dark:text-gray-300">Laden...</span>
  </div>
)}
```

**4. Add Pagination component at bottom of list:**
After the PersonListView component (around line 1146), add:
```jsx
{!isLoading && !error && people.length > 0 && totalPages > 1 && (
  <Pagination
    currentPage={page}
    totalPages={totalPages}
    totalItems={totalPeople}
    itemsPerPage={100}
    onPageChange={setPage}
  />
)}
```
  </action>
  <verify>
```bash
npm run build  # Must pass with no errors
npm run lint   # Check for lint errors in modified files
```

Manual testing after deploy in Task 4.
  </verify>
  <done>
- Filter UI uses label IDs with proper checkbox rendering
- Filter chips display label names from IDs
- Loading indicator shows during page transitions
- Pagination component renders at bottom of list
- Empty state handles "no results with filters" vs "no people at all"
  </done>
</task>

<task type="auto">
  <name>Task 4: Deploy and verify pagination</name>
  <files></files>
  <action>
1. Run final build check:
```bash
npm run build
```

2. Deploy to production:
```bash
bin/deploy.sh
```

3. Test pagination on production:
   - Visit People list page
   - Verify 100 people shown (not all 1400+)
   - Click page 2, verify different people shown
   - Click prev, verify returns to page 1
   - Verify page info shows correct counts

4. Test filter + pagination:
   - Apply a label filter
   - Verify page resets to 1
   - Verify results are filtered
   - Apply second filter (e.g., birth year)
   - Verify results update and page stays at 1

5. Test loading states:
   - Click page number
   - Observe subtle loading indicator
   - Verify previous data stays visible during load

6. Test empty states:
   - Apply restrictive filters that return 0 results
   - Verify "No leden vinden die aan je filters voldoen" message
   - Verify "Filters wissen" button works

7. Test sort:
   - Change sort field to last_name
   - Verify results re-sort (stay on current page or reset based on implementation)
   - Change sort direction
   - Verify order changes
  </action>
  <verify>
Production verification checklist:
- [ ] Page 1 shows first 100 people
- [ ] Pagination controls visible at bottom
- [ ] Page info shows "Tonen 1-100 van X leden"
- [ ] Click page 2 shows next 100 people
- [ ] Prev button disabled on page 1
- [ ] Next button disabled on last page
- [ ] Filter change resets to page 1
- [ ] Loading indicator shows during navigation
- [ ] Empty state shows with restrictive filters
- [ ] Sort changes work correctly
- [ ] Performance acceptable (page loads < 500ms)
  </verify>
  <done>
- Pagination deployed and functional on production
- All PAGE-* requirements verified:
  - PAGE-01: Displays 100 per page
  - PAGE-02: Can navigate with prev/next/page numbers
  - PAGE-03: Shows page/total info
  - PAGE-04: Filter changes reset to page 1
  - PAGE-05: Loading indicator during fetch
  - PAGE-06: Empty state for no results
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Pagination basics:**
   - People list shows 100 items per page
   - Pagination controls appear at bottom
   - Can navigate between pages
   - Page info accurate (X-Y of Z)

2. **Filter integration:**
   - Any filter change resets to page 1
   - Filters work with pagination (backend handles both)
   - Filter chips show correctly
   - Clear filters works

3. **Loading states:**
   - Initial load shows skeleton/spinner
   - Page navigation shows subtle indicator
   - Previous data visible during transition (no flash)

4. **Empty states:**
   - "No people" when total is 0
   - "No results" when filters exclude all

5. **Sort integration:**
   - Sort changes work (backend handles)
   - Custom field sort works (from Plan 01)

6. **No regressions:**
   - Add person button works
   - Bulk selection works (within current page)
   - Person links work
   - Pull to refresh works
</verification>

<success_criteria>
- PAGE-01: PeopleList displays paginated results (100 per page) - DONE
- PAGE-02: User can navigate between pages (prev/next/page numbers) - DONE
- PAGE-03: Current page and total pages are displayed - DONE
- PAGE-04: Filter changes reset to page 1 - DONE
- PAGE-05: Loading indicator shows while fetching page - DONE
- PAGE-06: Empty state when no results match filters - DONE
- All filter types work with pagination (labels, ownership, birth year, modified days)
- Sort works with pagination (first_name, last_name, modified, custom fields)
- Performance improved (loading 100 vs 1400+ items)
</success_criteria>

<output>
After completion, create `.planning/phases/113-frontend-pagination/113-02-SUMMARY.md`
</output>
