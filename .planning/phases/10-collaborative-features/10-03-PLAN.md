---
phase: 10-collaborative-features
plan: 03
type: execute
depends_on: ["10-02"]
files_modified: [includes/class-mention-notifications.php, includes/class-comment-types.php, src/pages/People/PersonDetail.jsx, functions.php]
---

<objective>
Wire up mention notifications and integrate MentionInput into the note creation flow.

Purpose: Notify users when they are @mentioned in notes, and replace the plain textarea with MentionInput for shared contacts.
Output: Mention notifications via existing channels, MentionInput integrated into PersonDetail.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-collaborative-features/10-RESEARCH.md
@.planning/phases/10-collaborative-features/10-02-SUMMARY.md (when available)

**Relevant source files:**
@includes/class-reminders.php (notification pattern reference)
@includes/class-notification-channel.php (base class)
@includes/class-email-channel.php (email implementation)
@src/pages/People/PersonDetail.jsx
@src/components/MentionInput/MentionInput.jsx

**From RESEARCH.md:**
- Use existing notification channels (Email, Slack)
- Batch mentions into digest OR immediate based on user preference
- Default: add to next digest (not immediate)
- User preference: stadion_mention_notifications = 'digest' (default) | 'immediate' | 'never'

**Constraining decisions:**
- Phase 10-02: stadion_user_mentioned action hook fires when mentions saved
- Existing: STADION_Reminders handles per-user scheduled notifications
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create STADION_Mention_Notifications class</name>
  <files>includes/class-mention-notifications.php, functions.php</files>
  <action>
  1. Create includes/class-mention-notifications.php:

  ```php
  <?php
  /**
   * Handles notifications when users are @mentioned
   */
  class STADION_Mention_Notifications {

      public function __construct() {
          add_action('stadion_user_mentioned', [$this, 'handle_mentions'], 10, 3);
      }

      /**
       * Handle mention notifications
       *
       * @param int $comment_id Comment ID
       * @param int[] $mentioned_user_ids Array of mentioned user IDs
       * @param int $author_id Author who wrote the note
       */
      public function handle_mentions($comment_id, $mentioned_user_ids, $author_id) {
          $comment = get_comment($comment_id);
          if (!$comment) return;

          $post = get_post($comment->comment_post_ID);
          if (!$post) return;

          $author = get_userdata($author_id);
          $author_name = $author ? $author->display_name : 'Someone';

          foreach ($mentioned_user_ids as $user_id) {
              // Don't notify yourself
              if ($user_id === $author_id) continue;

              // Check user preference
              $pref = get_user_meta($user_id, 'stadion_mention_notifications', true);
              if ($pref === 'never') continue;

              // Default to digest
              if (empty($pref)) $pref = 'digest';

              if ($pref === 'immediate') {
                  $this->send_immediate_notification($user_id, $author_name, $post, $comment);
              } else {
                  $this->queue_for_digest($user_id, $comment_id);
              }
          }
      }

      /**
       * Send immediate notification via email
       */
      private function send_immediate_notification($user_id, $author_name, $post, $comment) {
          $user = get_userdata($user_id);
          if (!$user || !$user->user_email) return;

          $post_title = $post->post_title;
          $post_url = home_url('/people/' . $post->ID);

          $subject = sprintf('%s mentioned you in a note about %s', $author_name, $post_title);
          $content = wp_strip_all_tags($comment->comment_content);
          $preview = strlen($content) > 200 ? substr($content, 0, 200) . '...' : $content;

          $message = sprintf(
              "<p>%s mentioned you in a note:</p>\n<blockquote>%s</blockquote>\n<p><a href=\"%s\">View %s</a></p>",
              esc_html($author_name),
              esc_html($preview),
              esc_url($post_url),
              esc_html($post_title)
          );

          wp_mail(
              $user->user_email,
              $subject,
              $message,
              ['Content-Type: text/html; charset=UTF-8']
          );
      }

      /**
       * Queue mention for inclusion in user's next digest
       */
      private function queue_for_digest($user_id, $comment_id) {
          $queued = get_user_meta($user_id, '_queued_mention_notifications', true);
          if (!is_array($queued)) $queued = [];

          // Add to queue if not already present
          if (!in_array($comment_id, $queued)) {
              $queued[] = $comment_id;
              update_user_meta($user_id, '_queued_mention_notifications', $queued);
          }
      }

      /**
       * Get and clear queued mentions for a user (called by STADION_Reminders)
       *
       * @param int $user_id User ID
       * @return array Array of mention data for digest
       */
      public static function get_queued_mentions($user_id) {
          $queued = get_user_meta($user_id, '_queued_mention_notifications', true);
          if (!is_array($queued) || empty($queued)) return [];

          $mentions = [];
          foreach ($queued as $comment_id) {
              $comment = get_comment($comment_id);
              if (!$comment) continue;

              $post = get_post($comment->comment_post_ID);
              if (!$post) continue;

              $author = get_userdata($comment->user_id);

              $mentions[] = [
                  'author' => $author ? $author->display_name : 'Someone',
                  'post_title' => $post->post_title,
                  'post_url' => home_url('/people/' . $post->ID),
                  'preview' => wp_trim_words(wp_strip_all_tags($comment->comment_content), 20),
              ];
          }

          // Clear the queue
          delete_user_meta($user_id, '_queued_mention_notifications');

          return $mentions;
      }
  }
  ```

  2. In functions.php, load and instantiate in stadion_init():
  ```php
  require_once get_template_directory() . '/includes/class-mention-notifications.php';
  new STADION_Mention_Notifications();
  ```

  Do NOT modify STADION_Reminders yet - that integration is Plan 05.
  </action>
  <verify>
  - Check class-mention-notifications.php exists with handle_mentions, queue_for_digest methods
  - Check functions.php loads and instantiates STADION_Mention_Notifications
  </verify>
  <done>Mention notifications queue or send immediately based on user preference</done>
</task>

<task type="auto">
  <name>Task 2: Integrate MentionInput into PersonDetail note creation</name>
  <files>src/pages/People/PersonDetail.jsx</files>
  <action>
  1. Import MentionInput component: `import MentionInput from '@/components/MentionInput';`
  2. Find the note creation form (textarea for adding notes)
  3. Replace textarea with MentionInput when contact has workspace visibility:

  Determine workspaceIds from contact data:
  - If person.visibility === 'workspace', get workspace IDs from person.assigned_workspaces
  - If person.visibility === 'private', use empty array (MentionInput shows plain textarea behavior)

  ```jsx
  const workspaceIds = person?.visibility === 'workspace'
    ? (person?.assigned_workspaces || [])
    : [];

  // In the note creation section:
  {workspaceIds.length > 0 ? (
    <MentionInput
      value={noteContent}
      onChange={setNoteContent}
      placeholder="Add a note... Use @ to mention someone"
      workspaceIds={workspaceIds}
    />
  ) : (
    <textarea
      value={noteContent}
      onChange={(e) => setNoteContent(e.target.value)}
      placeholder="Add a note..."
      className="w-full px-3 py-2 border border-gray-300 rounded-md resize-none"
      rows={3}
    />
  )}
  ```

  4. Ensure the note submission passes the raw value (with markup) to the API

  Keep backward compatibility - private contacts still use regular textarea.
  </action>
  <verify>
  - Check PersonDetail.jsx imports MentionInput
  - Check MentionInput used for workspace contacts, textarea for private
  </verify>
  <done>MentionInput integrated for workspace contacts, regular textarea for private contacts</done>
</task>

<task type="auto">
  <name>Task 3: Add mention notification preference to Settings page</name>
  <files>src/pages/Settings/Settings.jsx, includes/class-rest-api.php</files>
  <action>
  1. In Settings.jsx, add a "Mention Notifications" section after existing notification settings:

  ```jsx
  <div className="mt-6">
    <h4 className="text-sm font-medium text-gray-700 mb-2">Mention Notifications</h4>
    <select
      value={mentionNotifications}
      onChange={(e) => setMentionNotifications(e.target.value)}
      className="block w-full px-3 py-2 border border-gray-300 rounded-md"
    >
      <option value="digest">Include in daily digest (default)</option>
      <option value="immediate">Send immediately</option>
      <option value="never">Don't notify me</option>
    </select>
    <p className="mt-1 text-xs text-gray-500">
      Choose when to receive notifications when someone @mentions you in a note.
    </p>
  </div>
  ```

  2. Add state: `const [mentionNotifications, setMentionNotifications] = useState('digest');`

  3. Load preference on mount (add to existing settings fetch if available)

  4. In class-rest-api.php, update the settings endpoint to handle `mention_notifications`:
     - GET: return `get_user_meta($user_id, 'stadion_mention_notifications', true)` with default 'digest'
     - POST: `update_user_meta($user_id, 'stadion_mention_notifications', sanitize_text_field($value))`

  Keep implementation simple - no complex preference UI needed.
  </action>
  <verify>
  - Check Settings.jsx has mention notification dropdown
  - Check REST API saves/loads the preference
  </verify>
  <done>Users can configure mention notification preference in Settings</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Creating a note with @mention triggers notification to mentioned user
- [ ] Notification queued if user preference is 'digest' (check user meta)
- [ ] Notification sent immediately if user preference is 'immediate'
- [ ] No notification sent if preference is 'never'
- [ ] MentionInput appears for workspace contacts, regular textarea for private
- [ ] Settings page shows mention notification preference
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes
</verification>

<success_criteria>

- All tasks completed
- Mention notifications work end-to-end (either immediate or queued)
- Self-mentions are ignored
- UI allows users to control notification preference
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/10-collaborative-features/10-03-SUMMARY.md`
</output>
