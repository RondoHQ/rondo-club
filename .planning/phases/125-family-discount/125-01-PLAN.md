---
phase: 125-family-discount
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/class-membership-fees.php
autonomous: true

must_haves:
  truths:
    - "Postal codes are normalized (spaces removed, uppercase)"
    - "House numbers with additions are extracted correctly"
    - "Family key combines postal code and house number"
    - "Youth members with same family key are grouped together"
    - "Members with incomplete address data are excluded from grouping"
  artifacts:
    - path: "includes/class-membership-fees.php"
      provides: "Address normalization and family grouping methods"
      exports: ["normalize_postal_code", "extract_house_number", "get_family_key", "build_family_groups"]
  key_links:
    - from: "build_family_groups"
      to: "calculate_fee"
      via: "Uses calculate_fee to determine base_fee for sorting"
      pattern: "calculate_fee.*person_id"
---

<objective>
Add address normalization and family grouping methods to the MembershipFees class.

Purpose: Enable grouping youth members by household address for family discount calculation.
Output: Four new methods in class-membership-fees.php for address normalization, house number extraction, family key generation, and family group building.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/125-family-discount/125-CONTEXT.md
@.planning/phases/125-family-discount/125-RESEARCH.md
@.planning/phases/124-fee-calculation-engine/124-01-SUMMARY.md
@.planning/phases/124-fee-calculation-engine/124-02-SUMMARY.md
@includes/class-membership-fees.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add address normalization methods</name>
  <files>includes/class-membership-fees.php</files>
  <action>
Add two new methods to the MembershipFees class for Dutch address normalization:

1. `normalize_postal_code(string $postal_code): string`
   - Remove all whitespace using preg_replace('/\s+/', '', ...)
   - Trim the input first
   - Convert to uppercase with strtoupper()
   - Return the normalized postal code (e.g., "1234 ab" -> "1234AB")

2. `extract_house_number(string $street): ?string`
   - Trim the input string
   - Use regex to match number at end of street: `/(\d+)\s*[-\/]?\s*([a-zA-Z0-9]*)$/`
   - If match found:
     - Extract the number portion ($matches[1])
     - Extract the addition portion ($matches[2]), uppercase it
     - If addition is non-empty, return number + addition (e.g., "12A")
     - Otherwise return just the number (e.g., "12")
   - If no match, return null

Both methods should be public and have proper PHPDoc blocks following existing codebase style.
  </action>
  <verify>
Test via WP-CLI:
```bash
wp eval 'echo (new \Stadion\Fees\MembershipFees())->normalize_postal_code("1234 ab");'
# Should output: 1234AB

wp eval 'echo (new \Stadion\Fees\MembershipFees())->extract_house_number("Kerkstraat 12A");'
# Should output: 12A
```
  </verify>
  <done>
- normalize_postal_code removes spaces and uppercases ("1234 ab" -> "1234AB")
- extract_house_number extracts number with addition ("Kerkstraat 12A" -> "12A", "Straat 7" -> "7")
- Both methods handle edge cases (empty string, no match)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add family key generation method</name>
  <files>includes/class-membership-fees.php</files>
  <action>
Add the `get_family_key(int $person_id): ?string` method:

1. Get addresses from person using `get_field('addresses', $person_id) ?: []`
2. If empty, return null (no address data)
3. Use first address (index 0) as primary
4. Extract postal_code and street from the address array (with ?? '' fallback)
5. If either is empty, return null (incomplete address)
6. Normalize postal code using normalize_postal_code()
7. Extract house number using extract_house_number()
8. If house number is null, return null (could not parse)
9. Validate postal code format: must match `/^\d{4}[A-Z]{2}$/`
   - If invalid format, return null
10. Return family key as: `$normalized_postal . '-' . $house_number` (e.g., "1234AB-12A")

The key format matches CONTEXT.md decision: postal code + house number only (street name ignored).
House number additions ARE significant per CONTEXT.md: 12A and 12B are different families.
  </action>
  <verify>
Test via WP-CLI with a real person ID that has an address:
```bash
# Find a person with an address
wp eval '
$fees = new \Stadion\Fees\MembershipFees();
$query = new WP_Query(["post_type" => "person", "posts_per_page" => 5, "fields" => "ids"]);
foreach ($query->posts as $id) {
    $key = $fees->get_family_key($id);
    $addresses = get_field("addresses", $id) ?: [];
    if (!empty($addresses)) {
        echo "Person $id: " . ($addresses[0]["postal_code"] ?? "no-postal") . " -> " . ($key ?? "null") . "\n";
    }
}
'
```
  </verify>
  <done>
- get_family_key returns "POSTALCODE-HOUSENUMBER" format (e.g., "1234AB-12A")
- Returns null for persons without addresses
- Returns null for incomplete addresses (missing postal code or street)
- Returns null for invalid postal code format
- Uses first address as primary
  </done>
</task>

<task type="auto">
  <name>Task 3: Add family group building method</name>
  <files>includes/class-membership-fees.php</files>
  <action>
Add the `build_family_groups(?string $season = null): array` method:

1. Query all person posts:
   ```php
   $query = new \WP_Query([
       'post_type'      => 'person',
       'posts_per_page' => -1,
       'fields'         => 'ids',
       'no_found_rows'  => true,
   ]);
   ```

2. Initialize empty arrays: `$families = []` and `$person_data = []`

3. For each person_id in $query->posts:
   a. Calculate fee using calculate_fee($person_id)
   b. If null (not calculable), skip
   c. If category not in ['mini', 'pupil', 'junior'], skip (FAM-05: only youth eligible)
   d. Get family_key using get_family_key($person_id)
   e. If null (no valid address), skip
   f. Store person data: `$person_data[$person_id] = ['person_id' => $person_id, 'family_key' => $family_key, 'base_fee' => $fee_data['base_fee'], 'category' => $fee_data['category']]`
   g. Add to family group: `$families[$family_key][] = $person_id`

4. Process each family group:
   a. Skip if only one member (no discount possible)
   b. Get member data for all person_ids in the group
   c. Sort DESCENDING by base_fee (most expensive first = position 1 = full fee)
   d. If tie on base_fee, use person_id as secondary sort (lower ID first)
   e. Store sorted order

5. Return structured result:
   ```php
   return [
       'families' => $families,      // family_key => [person_ids]
       'person_data' => $person_data // person_id => {person_id, family_key, base_fee, category}
   ];
   ```

This method does NOT apply discounts - it just builds the groups. Plan 2 will use this to calculate discounts.
  </action>
  <verify>
Test via WP-CLI:
```bash
wp eval '
$fees = new \Stadion\Fees\MembershipFees();
$groups = $fees->build_family_groups();
echo "Total families: " . count($groups["families"]) . "\n";
echo "Total youth with addresses: " . count($groups["person_data"]) . "\n";

// Show families with multiple members
$multi = array_filter($groups["families"], fn($m) => count($m) > 1);
echo "Families with 2+ members: " . count($multi) . "\n";
if (!empty($multi)) {
    $sample = array_slice($multi, 0, 3, true);
    foreach ($sample as $key => $members) {
        echo "  $key: " . count($members) . " members\n";
    }
}
'
```
  </verify>
  <done>
- build_family_groups returns families and person_data arrays
- Only includes youth categories (mini, pupil, junior)
- Only includes persons with valid addresses
- Families are grouped by family_key
- Person data includes person_id, family_key, base_fee, category
  </done>
</task>

</tasks>

<verification>
All three methods work together:
```bash
wp eval '
$fees = new \Stadion\Fees\MembershipFees();

// Test normalization
echo "1. normalize_postal_code(\"1234 ab\") = " . $fees->normalize_postal_code("1234 ab") . "\n";

// Test house number extraction
echo "2. extract_house_number(\"Straat 12A\") = " . $fees->extract_house_number("Straat 12A") . "\n";

// Test build_family_groups
$groups = $fees->build_family_groups();
echo "3. Total youth with valid addresses: " . count($groups["person_data"]) . "\n";
echo "   Families with 2+ members: " . count(array_filter($groups["families"], fn($m) => count($m) > 1)) . "\n";
'
```

Expected output format:
```
1. normalize_postal_code("1234 ab") = 1234AB
2. extract_house_number("Straat 12A") = 12A
3. Total youth with valid addresses: [number]
   Families with 2+ members: [number]
```
</verification>

<success_criteria>
- [ ] normalize_postal_code normalizes Dutch postal codes correctly
- [ ] extract_house_number extracts house numbers with additions
- [ ] get_family_key generates family grouping keys from address data
- [ ] build_family_groups returns all youth grouped by family key
- [ ] Members without valid addresses are excluded (no error, just skipped)
- [ ] Only youth categories (mini/pupil/junior) included per FAM-05
</success_criteria>

<output>
After completion, create `.planning/phases/125-family-discount/125-01-SUMMARY.md`
</output>
