---
phase: 94-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/customfields/class-manager.php
  - includes/class-rest-custom-fields.php
  - includes/class-validation.php
  - functions.php
  - src/api/client.js
autonomous: true

must_haves:
  truths:
    - "Fields have a menu_order property that persists in database"
    - "Bulk reorder API updates menu_order for multiple fields in one request"
    - "Required fields are validated on save (frontend triggers, backend enforces)"
    - "Unique fields prevent duplicate values per post type per user"
  artifacts:
    - path: "includes/customfields/class-manager.php"
      provides: "menu_order in UPDATABLE_PROPERTIES, reorder_fields method"
      contains: "reorder_fields"
    - path: "includes/class-rest-custom-fields.php"
      provides: "PUT /rondo/v1/custom-fields/{post_type}/order endpoint"
      contains: "order"
    - path: "includes/class-validation.php"
      provides: "Unique validation via ACF validate_value hook"
      contains: "stadion_validate_custom_field"
    - path: "src/api/client.js"
      provides: "reorderCustomFields API method"
      contains: "reorderCustomFields"
  key_links:
    - from: "src/api/client.js"
      to: "/rondo/v1/custom-fields/{post_type}/order"
      via: "PUT request"
      pattern: "custom-fields.*order"
    - from: "includes/class-validation.php"
      to: "acf/validate_value"
      via: "add_filter hook"
      pattern: "acf/validate_value"
---

<objective>
Add backend support for field reordering and unique validation

Purpose: Enable drag-and-drop reorder in UI and enforce unique constraints on custom field values
Output: REST endpoint for bulk reorder, menu_order field property, unique validation hook
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/94-polish/94-RESEARCH.md

@includes/customfields/class-manager.php
@includes/class-rest-custom-fields.php
@src/api/client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add menu_order and reorder_fields to Manager</name>
  <files>includes/customfields/class-manager.php</files>
  <action>
1. Add 'menu_order' to UPDATABLE_PROPERTIES array (after 'list_view_order')

2. Add 'unique' to UPDATABLE_PROPERTIES array (for unique validation flag)

3. Add new method reorder_fields():
```php
/**
 * Reorder fields by setting menu_order.
 *
 * @param string $post_type The post type.
 * @param array  $field_keys Array of field keys in desired order.
 * @return bool|WP_Error True on success, WP_Error on failure.
 */
public function reorder_fields( string $post_type, array $field_keys ) {
    if ( ! $this->is_valid_post_type( $post_type ) ) {
        return new WP_Error( 'invalid_post_type', 'Invalid post type.' );
    }

    foreach ( $field_keys as $menu_order => $field_key ) {
        $field = acf_get_field( $field_key );
        if ( $field ) {
            $field['menu_order'] = $menu_order + 1; // Start at 1, not 0
            acf_update_field( $field );
        }
    }

    return true;
}
```

Note: ACF already sorts fields by menu_order, so get_fields() will automatically return fields in the new order after reordering.
  </action>
  <verify>Grep for 'menu_order' and 'reorder_fields' in class-manager.php confirms additions</verify>
  <done>Manager class supports menu_order property and bulk reorder operation</done>
</task>

<task type="auto">
  <name>Task 2: Add reorder endpoint and unique to REST API</name>
  <files>includes/class-rest-custom-fields.php, src/api/client.js</files>
  <action>
1. In class-rest-custom-fields.php, add new route in register_routes() AFTER the metadata route, BEFORE the single item route:

```php
// Reorder fields route.
register_rest_route(
    $this->namespace,
    '/' . $this->rest_base . '/(?P<post_type>person|team)/order',
    array(
        array(
            'methods'             => WP_REST_Server::EDITABLE,
            'callback'            => array( $this, 'reorder_items' ),
            'permission_callback' => array( $this, 'update_item_permissions_check' ),
            'args'                => array(
                'order' => array(
                    'type'        => 'array',
                    'items'       => array( 'type' => 'string' ),
                    'required'    => true,
                    'description' => 'Array of field keys in desired order',
                ),
            ),
        ),
    )
);
```

2. Add reorder_items callback method:

```php
/**
 * Reorder custom fields.
 *
 * @param WP_REST_Request $request The REST request object.
 * @return WP_REST_Response|WP_Error Success response or error.
 */
public function reorder_items( $request ) {
    $post_type = $request->get_param( 'post_type' );
    $order     = $request->get_param( 'order' );

    $result = $this->manager->reorder_fields( $post_type, $order );

    if ( is_wp_error( $result ) ) {
        $result->add_data( array( 'status' => 400 ) );
        return $result;
    }

    return rest_ensure_response( array( 'success' => true ) );
}
```

3. Add 'unique' to optional_params in create_item() and updatable_params in update_item()

4. Add 'unique' to get_create_params():
```php
'unique' => array(
    'type'        => 'boolean',
    'default'     => false,
    'description' => 'Enforce unique values per post type',
),
```

5. In src/api/client.js, add after deleteCustomField:
```javascript
reorderCustomFields: (postType, order) => api.put(`/rondo/v1/custom-fields/${postType}/order`, { order }),
```
  </action>
  <verify>
curl -X PUT localhost/wp-json/rondo/v1/custom-fields/person/order with admin auth returns 200;
Grep for 'reorderCustomFields' in client.js confirms addition
  </verify>
  <done>REST API has PUT /order endpoint, frontend client has reorderCustomFields method</done>
</task>

<task type="auto">
  <name>Task 3: Add unique validation class</name>
  <files>includes/class-validation.php, functions.php</files>
  <action>
1. Create new file includes/class-validation.php:

```php
<?php
/**
 * Custom Fields Validation
 *
 * Provides validation hooks for custom field values including unique constraint.
 *
 * @package Stadion\CustomFields
 */

namespace Stadion\CustomFields;

if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

/**
 * Validation class for custom fields.
 *
 * Handles unique validation via ACF's validate_value hook.
 */
class Validation {

    /**
     * Constructor.
     *
     * Registers ACF validation hooks.
     */
    public function __construct() {
        add_filter( 'acf/validate_value', array( $this, 'validate_unique' ), 10, 4 );
    }

    /**
     * Validate unique constraint for custom fields.
     *
     * Checks if a field marked as unique has a duplicate value in another post
     * of the same type owned by the same user.
     *
     * @param bool|string $valid      True if valid, error message string if invalid.
     * @param mixed       $value      The field value being validated.
     * @param array       $field      The field configuration.
     * @param string      $input_name The input name (for error targeting).
     * @return bool|string True if valid, error message if invalid.
     */
    public function validate_unique( $valid, $value, $field, $input_name ) {
        // Bail early if already invalid.
        if ( $valid !== true ) {
            return $valid;
        }

        // Only check our custom fields (key prefix check).
        if ( strpos( $field['key'], 'field_custom_' ) !== 0 ) {
            return $valid;
        }

        // Only check if field is marked unique and has a value.
        if ( empty( $field['unique'] ) || $value === '' || $value === null ) {
            return $valid;
        }

        // Get current post ID from the $_POST data.
        $post_id = 0;
        if ( isset( $_POST['post_ID'] ) ) {
            $post_id = (int) $_POST['post_ID'];
        } elseif ( isset( $_POST['post_id'] ) ) {
            $post_id = (int) $_POST['post_id'];
        }

        // Determine post type from field key.
        // Field keys are like: field_custom_person_xxx or field_custom_team_xxx
        $post_type = null;
        if ( strpos( $field['key'], 'field_custom_person_' ) === 0 ) {
            $post_type = 'person';
        } elseif ( strpos( $field['key'], 'field_custom_team_' ) === 0 ) {
            $post_type = 'team';
        }

        if ( ! $post_type ) {
            return $valid;
        }

        // Query for existing posts with same value (same user, same post type).
        $query_args = array(
            'post_type'      => $post_type,
            'posts_per_page' => 1,
            'fields'         => 'ids',
            'author'         => get_current_user_id(),
            'meta_query'     => array(
                array(
                    'key'     => $field['name'],
                    'value'   => $value,
                    'compare' => '=',
                ),
            ),
        );

        // Exclude current post if editing.
        if ( $post_id ) {
            $query_args['post__not_in'] = array( $post_id );
        }

        $existing = get_posts( $query_args );

        if ( ! empty( $existing ) ) {
            return sprintf(
                __( '%s must be unique. This value is already in use.', 'stadion' ),
                $field['label']
            );
        }

        return $valid;
    }
}
```

2. In functions.php, add to rondo_init() function after the CustomFields REST API initialization (around line where other classes are instantiated):

```php
// Initialize custom field validation.
new \Stadion\CustomFields\Validation();
```
  </action>
  <verify>Grep for 'Validation' in functions.php confirms instantiation; class-validation.php exists with validate_unique method</verify>
  <done>Unique validation enforced via ACF hook, scoped to current user's posts</done>
</task>

</tasks>

<verification>
1. Backend menu_order: Create field via API, update menu_order, verify field has menu_order in database
2. Reorder endpoint: PUT /rondo/v1/custom-fields/person/order with array of keys returns success
3. Unique validation: Create person with custom field value, try to create another with same value, should fail validation
</verification>

<success_criteria>
- Manager.reorder_fields() persists menu_order for all fields in array
- PUT /custom-fields/{post_type}/order endpoint accepts array of field keys
- Unique validation triggers for fields with unique=true flag
- Frontend client has reorderCustomFields method
</success_criteria>

<output>
After completion, create `.planning/phases/94-polish/94-01-SUMMARY.md`
</output>
