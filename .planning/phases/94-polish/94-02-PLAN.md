---
phase: 94-polish
plan: 02
type: execute
wave: 2
depends_on: ["94-01"]
files_modified:
  - src/pages/Settings/CustomFields.jsx
  - src/components/FieldFormPanel.jsx
autonomous: true

must_haves:
  truths:
    - "Admin can drag fields to reorder them in Settings"
    - "New field order persists after page refresh"
    - "Admin can toggle required checkbox when editing field"
    - "Admin can toggle unique checkbox when editing field"
    - "Placeholder input appears for text, textarea, email, url, number, and select fields"
  artifacts:
    - path: "src/pages/Settings/CustomFields.jsx"
      provides: "DndContext, SortableContext wrapper, SortableFieldRow component"
      contains: "DndContext"
    - path: "src/components/FieldFormPanel.jsx"
      provides: "Required toggle, unique toggle in Validation Options section"
      contains: "Validation Options"
  key_links:
    - from: "src/pages/Settings/CustomFields.jsx"
      to: "prmApi.reorderCustomFields"
      via: "mutation onDragEnd"
      pattern: "reorderCustomFields"
    - from: "src/components/FieldFormPanel.jsx"
      to: "submitData.required"
      via: "form submission"
      pattern: "required"
---

<objective>
Add drag-and-drop field reordering and validation options to Settings UI

Purpose: Complete the custom fields polish with visual reordering and required/unique toggles
Output: Sortable field list in Settings, validation options in FieldFormPanel
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/94-polish/94-RESEARCH.md
@.planning/phases/94-polish/94-01-SUMMARY.md

@src/pages/Settings/CustomFields.jsx
@src/components/FieldFormPanel.jsx
@src/components/DashboardCustomizeModal.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add drag-and-drop to CustomFields.jsx</name>
  <files>src/pages/Settings/CustomFields.jsx</files>
  <action>
Follow the pattern from DashboardCustomizeModal.jsx exactly:

1. Add imports at top:
```javascript
import { GripVertical } from 'lucide-react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  TouchSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
```

2. Create SortableFieldRow component OUTSIDE the main component (before export default):
```javascript
function SortableFieldRow({ field, onEdit, onDelete, getFieldTypeLabel }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: field.key });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    zIndex: isDragging ? 50 : undefined,
  };

  return (
    <tr
      ref={setNodeRef}
      style={style}
      className={`group hover:bg-gray-50 dark:hover:bg-gray-800 ${isDragging ? 'shadow-lg opacity-90 bg-white dark:bg-gray-900' : ''}`}
    >
      <td className="px-2 py-4 w-10">
        <button
          {...attributes}
          {...listeners}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 cursor-grab active:cursor-grabbing touch-none"
          aria-label="Drag to reorder"
        >
          <GripVertical className="w-4 h-4" />
        </button>
      </td>
      <td className="px-4 py-4 whitespace-nowrap">
        <div className="font-medium text-gray-900 dark:text-gray-100">
          {field.label}
          {field.required && <span className="text-red-500 ml-1">*</span>}
        </div>
        {field.instructions && (
          <div className="text-sm text-gray-500 dark:text-gray-400 truncate max-w-xs">
            {field.instructions}
          </div>
        )}
      </td>
      <td className="px-4 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
        {getFieldTypeLabel(field.type)}
      </td>
      <td className="px-4 py-4 whitespace-nowrap text-right">
        <div className="flex justify-end gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
          <button
            onClick={() => onEdit(field)}
            className="p-2 text-gray-600 dark:text-gray-400 hover:text-accent-600 dark:hover:text-accent-400 hover:bg-accent-50 dark:hover:bg-accent-900/30 rounded"
            title="Edit"
          >
            <Edit2 className="w-4 h-4" />
          </button>
          <button
            onClick={() => onDelete(field)}
            className="p-2 text-gray-600 dark:text-gray-400 hover:text-red-600 dark:hover:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/30 rounded"
            title="Delete"
          >
            <Trash2 className="w-4 h-4" />
          </button>
        </div>
      </td>
    </tr>
  );
}
```

3. Inside CustomFields component, add sensors configuration (after queryClient):
```javascript
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: { distance: 8 },
  }),
  useSensor(TouchSensor, {
    activationConstraint: { delay: 200, tolerance: 8 },
  }),
  useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates,
  })
);
```

4. Add reorder mutation (after deleteMutation):
```javascript
const reorderMutation = useMutation({
  mutationFn: async (order) => prmApi.reorderCustomFields(activeTab, order),
  onMutate: async (order) => {
    await queryClient.cancelQueries({ queryKey: ['custom-fields', activeTab] });
    const previousFields = queryClient.getQueryData(['custom-fields', activeTab]);
    const reorderedFields = order.map(key => previousFields.find(f => f.key === key));
    queryClient.setQueryData(['custom-fields', activeTab], reorderedFields);
    return { previousFields };
  },
  onError: (err, order, context) => {
    queryClient.setQueryData(['custom-fields', activeTab], context.previousFields);
  },
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['custom-fields', activeTab] });
  },
});
```

5. Add handleDragEnd function:
```javascript
const handleDragEnd = (event) => {
  const { active, over } = event;
  if (over && active.id !== over.id) {
    const oldIndex = fields.findIndex(f => f.key === active.id);
    const newIndex = fields.findIndex(f => f.key === over.id);
    const newOrder = arrayMove(fields, oldIndex, newIndex).map(f => f.key);
    reorderMutation.mutate(newOrder);
  }
};
```

6. Update the table header row to add drag column:
```jsx
<thead className="bg-gray-50 dark:bg-gray-800">
  <tr>
    <th scope="col" className="px-2 py-3 w-10">
      <span className="sr-only">Reorder</span>
    </th>
    <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
      Label
    </th>
    ...
  </tr>
</thead>
```

7. Wrap the tbody content with DndContext and SortableContext:
```jsx
<DndContext
  sensors={sensors}
  collisionDetection={closestCenter}
  onDragEnd={handleDragEnd}
>
  <SortableContext items={fields.map(f => f.key)} strategy={verticalListSortingStrategy}>
    <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
      {fields.map((field) => (
        <SortableFieldRow
          key={field.key}
          field={field}
          onEdit={handleEditField}
          onDelete={handleDeleteField}
          getFieldTypeLabel={getFieldTypeLabel}
        />
      ))}
    </tbody>
  </SortableContext>
</DndContext>
```

Note: The table structure requires tbody to be a direct child of table for valid HTML. The DndContext wraps outside the table, or wrap both thead and DndContext content appropriately. If needed, restructure to use divs instead of table for drag-drop compatibility.

Actually, for table drag-drop to work cleanly, keep DndContext outside the table and use CSS table display on divs, OR keep table structure and just wrap the map in SortableContext. Test both approaches - the simpler approach is to keep the table and rely on CSS.Transform working on tr elements.
  </action>
  <verify>npm run build passes; field list shows drag handles; dragging field updates order immediately</verify>
  <done>Settings CustomFields page has working drag-and-drop with optimistic updates and auto-save on drop</done>
</task>

<task type="auto">
  <name>Task 2: Add validation options to FieldFormPanel</name>
  <files>src/components/FieldFormPanel.jsx</files>
  <action>
1. Add to getDefaultFormData() after 'list_view_order':
```javascript
// Validation options
required: false,
unique: false,
```

2. In the useEffect that sets formData when editing, add after list_view_order:
```javascript
// Validation options
required: field.required ?? false,
unique: field.unique ?? false,
```

3. Add a new "Validation Options" section in the form BEFORE the "Display Options" section (around line 1257). Insert this new section:
```jsx
{/* Validation Options */}
<div className="pt-4 border-t border-gray-200 dark:border-gray-700">
  <h4 className="text-sm font-medium text-gray-600 dark:text-gray-400 mb-3">Validation Options</h4>
  <div className="space-y-3">
    <div className="flex items-center gap-2">
      <input
        id="required"
        name="required"
        type="checkbox"
        checked={formData.required}
        onChange={handleChange}
        className="w-4 h-4 rounded border-gray-300 dark:border-gray-600 text-accent-600 focus:ring-accent-500"
      />
      <label htmlFor="required" className="text-sm text-gray-700 dark:text-gray-300">
        Required field
      </label>
    </div>
    <p className={hintClass}>Users must provide a value when saving</p>

    <div className="flex items-center gap-2 mt-4">
      <input
        id="unique"
        name="unique"
        type="checkbox"
        checked={formData.unique}
        onChange={handleChange}
        className="w-4 h-4 rounded border-gray-300 dark:border-gray-600 text-accent-600 focus:ring-accent-500"
      />
      <label htmlFor="unique" className="text-sm text-gray-700 dark:text-gray-300">
        Unique value
      </label>
    </div>
    <p className={hintClass}>No two records can have the same value for this field</p>
  </div>
</div>
```

4. In handleSubmit, add validation options to submitData after the list view settings block (around line 358):
```javascript
// Validation options
submitData.required = formData.required;
submitData.unique = formData.unique;
```

5. Add placeholder support for number field type. In the renderTypeOptions switch case for 'number' (around line 495), add a placeholder input after the step/prepend/append grid:
```jsx
<div className="mt-4">
  <label htmlFor="placeholder" className={labelClass}>
    Placeholder
  </label>
  <input
    id="placeholder"
    name="placeholder"
    type="text"
    value={formData.placeholder}
    onChange={handleChange}
    placeholder="e.g., Enter amount"
    className={inputClass}
  />
</div>
```

6. Add placeholder to number field submission. In handleSubmit, inside the formData.type === 'number' block, add:
```javascript
if (formData.placeholder) submitData.placeholder = formData.placeholder;
```

7. Add placeholder support for select field type. In the renderTypeOptions switch case for 'select' (around line 696), add after the allow_null checkbox:
```jsx
<div className="mt-4">
  <label htmlFor="placeholder" className={labelClass}>
    Placeholder
  </label>
  <input
    id="placeholder"
    name="placeholder"
    type="text"
    value={formData.placeholder}
    onChange={handleChange}
    placeholder="e.g., Select an option..."
    className={inputClass}
  />
  <p className={hintClass}>Shown when no option is selected</p>
</div>
```

8. Add placeholder to select field submission. In handleSubmit, inside the select block (around line 288), add:
```javascript
if (formData.placeholder) submitData.placeholder = formData.placeholder;
```
  </action>
  <verify>npm run build passes; editing field shows Required and Unique checkboxes; number and select fields show placeholder input</verify>
  <done>FieldFormPanel has Validation Options section with required/unique toggles, placeholder for number and select fields</done>
</task>

</tasks>

<verification>
1. Drag-and-drop: Drag a field in Settings, refresh page, field stays in new position
2. Required flag: Enable required on field, shows asterisk in list, value included in API call
3. Unique flag: Enable unique on field, save, API call includes unique: true
4. Placeholder on number: Edit number field, placeholder input visible and saves
5. Placeholder on select: Edit select field, placeholder input visible and saves
</verification>

<success_criteria>
- Field list has drag handles, dragging reorders with optimistic update
- New order persists via reorderCustomFields API call
- Required checkbox toggles field.required
- Unique checkbox toggles field.unique
- Number and select field types have placeholder option
</success_criteria>

<output>
After completion, create `.planning/phases/94-polish/94-02-SUMMARY.md`
</output>
